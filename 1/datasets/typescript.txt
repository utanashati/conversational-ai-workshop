import { Observable } from 'rxjs'; import { AbstractControl } from '../model'; import { ValidationErrors } from './validators'; export declare abstract class AbstractControlDirective { abstract readonly control: AbstractControl | null; readonly value: any; readonly valid: boolean | null; readonly invalid: boolean | null; readonly pending: boolean | null; readonly disabled: boolean | null; readonly enabled: boolean | null; readonly errors: ValidationErrors | null; readonly pristine: boolean | null; readonly dirty: boolean | null; readonly touched: boolean | null; readonly status: string | null; readonly untouched: boolean | null; readonly statusChanges: Observable<any> | null; readonly valueChanges: Observable<any> | null; readonly path: string[] | null; reset(value?: any): void; hasError(errorCode: string, path?: string[]): boolean; getError(errorCode: string, path?: string[]): any; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': string[]; 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/observable/UsingObservable';
export * from 'rxjs-compat/operator/timeoutWith';
import { LocationStrategy } from './location_strategy'; import { LocationChangeListener, PlatformLocation } from './platform_location'; export declare class HashLocationStrategy extends LocationStrategy { private _platformLocation; private _baseHref; constructor(_platformLocation: PlatformLocation, _baseHref?: string); onPopState(fn: LocationChangeListener): void; getBaseHref(): string; path(includeHash?: boolean): string; prepareExternalUrl(internal: string): string; pushState(state: any, title: string, path: string, queryParams: string): void; replaceState(state: any, title: string, path: string, queryParams: string): void; forward(): void; back(): void; }
import { CustomReporterResult } from "../../custom-reporter-result"; import { DisplayProcessor } from "../display-processor"; export declare class DefaultProcessor extends DisplayProcessor { private static displaySpecDescription(spec); displayJasmineStarted(): String; displaySuite(suite: CustomReporterResult): String; displaySuccessfulSpec(spec: CustomReporterResult): String; displayFailedSpec(spec: CustomReporterResult): String; displaySpecErrorMessages(spec: CustomReporterResult): String; displaySummaryErrorMessages(spec: CustomReporterResult): String; displayPendingSpec(spec: CustomReporterResult): String; private displayErrorMessages(spec, withStacktrace); }
import 'rxjs-compat/add/operator/skipLast';
export declare function createUrlResolverWithoutPackagePrefix(): UrlResolver; export declare function createOfflineCompileUrlResolver(): UrlResolver; export interface UrlResolver { resolve(baseUrl: string, url: string): string; } export interface UrlResolverCtor { new (packagePrefix?: string | null): UrlResolver; } export declare const UrlResolver: UrlResolverCtor; export declare function getUrlScheme(url: string): string;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; } | undefined)[]; export default _default;
declare const mimicFn: { < ArgumentsType extends unknown[], ReturnType, FunctionType extends (...arguments: ArgumentsType) => ReturnType >( to: (...arguments: ArgumentsType) => ReturnType, from: FunctionType ): FunctionType; default: typeof mimicFn; }; export = mimicFn;
import { logging } from '@angular-devkit/core'; import { CommandWorkspace } from './interface'; export interface CommandMapOptions { [key: string]: string; } export declare function runCommand(args: string[], logger: logging.Logger, workspace: CommandWorkspace, commands?: CommandMapOptions): Promise<number | void>;
export { NgZone, NoopNgZone as ɵNoopNgZone } from './zone/ng_zone';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'LAK': string[]; 'THB': string[]; 'TWD': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/InnerSubscriber';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import * as ts from 'typescript'; import { TypeCheckContext } from './context'; export declare class TypeCheckProgramHost implements ts.CompilerHost { private delegate; private context; private sfCache; private augmentedSourceFiles; constructor(program: ts.Program, delegate: ts.CompilerHost, context: TypeCheckContext); getSourceFile(fileName: string, languageVersion: ts.ScriptTarget, onError?: ((message: string) => void) | undefined, shouldCreateNewSourceFile?: boolean | undefined): ts.SourceFile | undefined; getDefaultLibFileName(options: ts.CompilerOptions): string; writeFile(fileName: string, data: string, writeByteOrderMark: boolean, onError: ((message: string) => void) | undefined, sourceFiles: ReadonlyArray<ts.SourceFile>): void; getCurrentDirectory(): string; getDirectories(path: string): string[]; getCanonicalFileName(fileName: string): string; useCaseSensitiveFileNames(): boolean; getNewLine(): string; fileExists(fileName: string): boolean; readFile(fileName: string): string | undefined; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'PLN': string[]; 'THB': string[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/operator/buffer';
export * from 'rxjs-compat/observable/EmptyObservable';
export declare const ISO8601_DATE_REGEX: RegExp; export declare function formatDate(value: string | number | Date, format: string, locale: string, timezone?: string): string; export declare function toDate(value: string | number | Date): Date; export declare function isoStringToDate(match: RegExpMatchArray): Date; export declare function isDate(value: any): value is Date;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'ESP': string[]; 'EUR': (string | undefined)[]; 'FKP': (string | undefined)[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NZD': (string | undefined)[]; 'RON': (string | undefined)[]; 'SSP': (string | undefined)[]; 'SYP': (string | undefined)[]; 'TWD': (string | undefined)[]; 'VEF': (string | undefined)[]; 'VND': (string | undefined)[]; 'XAF': never[]; 'XCD': (string | undefined)[]; 'XOF': never[]; } | undefined)[]; export default _default;
import * as ast from '@angular/compiler'; import * as ts from 'typescript'; import * as Lint from 'tslint'; import * as e from '@angular/compiler/src/expression_parser/ast'; import { ComponentMetadata } from '../metadata'; import { SourceMappingVisitor } from '../sourceMappingVisitor'; export interface RecursiveAngularExpressionVisitorCtr { new (sourceFile: ts.SourceFile, options: Lint.IOptions, context: ComponentMetadata, basePosition: number): any; } export interface TemplateAstVisitorCtr { new (sourceFile: ts.SourceFile, options: Lint.IOptions, context: ComponentMetadata, templateStart: number, expressionVisitorCtrl: RecursiveAngularExpressionVisitorCtr): any; } export declare class BasicTemplateAstVisitor extends SourceMappingVisitor implements ast.TemplateAstVisitor { private _originalOptions; protected context: ComponentMetadata; protected templateStart: number; private expressionVisitorCtrl; private _variables; constructor(sourceFile: ts.SourceFile, _originalOptions: Lint.IOptions, context: ComponentMetadata, templateStart: number, expressionVisitorCtrl?: RecursiveAngularExpressionVisitorCtr); visit?(node: ast.TemplateAst, context: any): any; visitNgContent(ast: ast.NgContentAst, context: any): any; visitEmbeddedTemplate(ast: ast.EmbeddedTemplateAst, context: any): any; visitElement(element: ast.ElementAst, context: any): any; visitReference(ast: ast.ReferenceAst, context: any): any; visitVariable(ast: ast.VariableAst, context: any): any; visitEvent(ast: ast.BoundEventAst, context: any): any; visitElementProperty(prop: ast.BoundElementPropertyAst, context: any): any; visitAttr(ast: ast.AttrAst, context: any): any; visitBoundText(text: ast.BoundTextAst, context: any): any; visitText(text: ast.TextAst, context: any): any; visitDirective(ast: ast.DirectiveAst, context: any): any; visitDirectiveProperty(prop: ast.BoundDirectivePropertyAst, context: any): any; protected visitNgTemplateAST(ast: e.AST, templateStart: number, prop?: any): void; }
import 'rxjs-compat/add/operator/bufferCount';
import { Options } from './options'; import { Program, Programs } from './programs'; export declare class Cli { programs: Programs; usageText: string; version: string; program(prog: Program): Cli; usage(usageText: string): Cli; printHelp(): void; posCmdDescription(): number; posDescription(): number; posDefault(): number; getOptions(): Options; getMinimistOptions(): Object; }
export {};
import { NgZone } from '../zone/ng_zone'; export declare interface PublicTestability { isStable(): boolean; whenStable(callback: Function, timeout?: number, updateCallback?: Function): void; findProviders(using: any, provider: string, exactMatch: boolean): any[]; } export interface PendingMacrotask { source: string; creationLocation: Error; runCount?: number; data: TaskData; } export interface TaskData { target?: XMLHttpRequest; delay?: number; isPeriodic?: boolean; } export declare type DoneCallback = (didWork: boolean, tasks?: PendingMacrotask[]) => void; export declare type UpdateCallback = (tasks: PendingMacrotask[]) => boolean; export declare class Testability implements PublicTestability { private _ngZone; private _pendingCount; private _isZoneStable; private _callbacks; private taskTrackingZone; constructor(_ngZone: NgZone); private _watchAngularEvents; increasePendingRequestCount(): number; decreasePendingRequestCount(): number; isStable(): boolean; private _runCallbacksIfReady; private getPendingTasks; private addCallback; whenStable(doneCb: Function, timeout?: number, updateCb?: Function): void; getPendingRequestCount(): number; findProviders(using: any, provider: string, exactMatch: boolean): any[]; } export declare class TestabilityRegistry { constructor(); registerApplication(token: any, testability: Testability): void; unregisterApplication(token: any): void; unregisterAllApplications(): void; getTestability(elem: any): Testability | null; getAllTestabilities(): Testability[]; getAllRootElements(): any[]; findTestabilityInTree(elem: Node, findInAncestors?: boolean): Testability | null; } export interface GetTestability { addToWindow(registry: TestabilityRegistry): void; findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean): Testability | null; } export declare function setTestabilityGetter(getter: GetTestability): void;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': string[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/operator/bufferCount';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'TZS': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export * from './index'; export { CachedResourceLoader as ɵangular_packages_platform_browser_dynamic_platform_browser_dynamic_a } from './src/resource_loader/resource_loader_cache';
declare const _default: (string[][] | undefined)[]; export default _default;
export * from './src/testing';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': string[]; 'RON': (string | undefined)[]; 'THB': string[]; 'TRY': string[]; 'TWD': string[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/operators/toArray';
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import { QueryList } from '../../linker'; import { Type } from '../../type'; import { TContainerNode, TElementContainerNode, TElementNode } from './node'; export interface LQueries { parent: LQueries | null; clone(): LQueries; addNode(tNode: TElementNode | TContainerNode | TElementContainerNode): LQueries | null; container(): LQueries | null; createView(): LQueries | null; insertView(newViewIndex: number): void; removeView(): void; track<T>(queryList: QueryList<T>, predicate: Type<any> | string[], descend?: boolean, read?: Type<T>): void; } export declare const unusedValueExportToPlacateAjd = 1;
export * from 'rxjs-compat/operators/timeInterval';
import {patchEventTarget} from '../common/events'; import {ADD_EVENT_LISTENER_STR, ArraySlice, ObjectCreate, ObjectGetOwnPropertyDescriptor, patchOnProperties, REMOVE_EVENT_LISTENER_STR} from '../common/utils'; export function apply(api: _ZonePrivate, _global: any) { const WS = (<any>_global).WebSocket; if (!(<any>_global).EventTarget) { patchEventTarget(_global, [WS.prototype]); } (<any>_global).WebSocket = function(x: any, y: any) { const socket = arguments.length > 1 ? new WS(x, y) : new WS(x); let proxySocket: any; let proxySocketProto: any; const onmessageDesc = ObjectGetOwnPropertyDescriptor(socket, 'onmessage'); if (onmessageDesc && onmessageDesc.configurable === false) { proxySocket = ObjectCreate(socket); proxySocketProto = socket; [ADD_EVENT_LISTENER_STR, REMOVE_EVENT_LISTENER_STR, 'send', 'close'].forEach(function( propName) { proxySocket[propName] = function() { const args = ArraySlice.call(arguments); if (propName === ADD_EVENT_LISTENER_STR || propName === REMOVE_EVENT_LISTENER_STR) { const eventName = args.length > 0 ? args[0] : undefined; if (eventName) { const propertySymbol = Zone.__symbol__('ON_PROPERTY' + eventName); socket[propertySymbol] = proxySocket[propertySymbol]; } } return socket[propName].apply(socket, args); }; }); } else { proxySocket = socket; } patchOnProperties(proxySocket, ['close', 'error', 'message', 'open'], proxySocketProto); return proxySocket; }; const globalWebSocket = _global['WebSocket']; for (const prop in WS) { globalWebSocket[prop] = WS[prop]; } }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
import { IRuleMetadata, RuleFailure, Rules } from 'tslint/lib'; import { SourceFile } from 'typescript/lib/typescript'; export declare class Rule extends Rules.AbstractRule { static readonly metadata: IRuleMetadata; static readonly DEFAULT_MAX_COMPLEXITY: number; static readonly FAILURE_STRING: string; apply(sourceFile: SourceFile): RuleFailure[]; isEnabled(): boolean; } export declare const getFailureMessage: (totalComplexity: number, maxComplexity?: number) => string;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare const _default: (string[][] | undefined)[]; export default _default;
export interface Schema { configuration?: string; help?: HelpUnion; project?: string; } export declare type HelpUnion = boolean | HelpEnum; export declare enum HelpEnum { HelpJSON = "JSON", JSON = "json" }
import {Operator} from '../Operator'; import {Subscriber} from '../Subscriber'; import {Observable} from '../Observable'; import {OuterSubscriber} from '../OuterSubscriber'; import { InnerSubscriber } from '../InnerSubscriber'; import {subscribeToResult} from '../util/subscribeToResult'; import {ObservableInput, OperatorFunction, MonoTypeOperatorFunction} from '../types'; export function catchError<T>(selector: (err: any, caught: Observable<T>) => never): MonoTypeOperatorFunction<T>; export function catchError<T, R>(selector: (err: any, caught: Observable<T>) => ObservableInput<R>): OperatorFunction<T, T | R>; export function catchError<T, R>(selector: (err: any, caught: Observable<T>) => ObservableInput<R>): OperatorFunction<T, T | R> { return function catchErrorOperatorFunction(source: Observable<T>): Observable<T | R> { const operator = new CatchOperator(selector); const caught = source.lift(operator); return (operator.caught = caught as Observable<T>); }; } class CatchOperator<T, R> implements Operator<T, T | R> { caught: Observable<T>; constructor(private selector: (err: any, caught: Observable<T>) => ObservableInput<T | R>) { } call(subscriber: Subscriber<R>, source: any): any { return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught)); } } class CatchSubscriber<T, R> extends OuterSubscriber<T, T | R> { constructor(destination: Subscriber<any>, private selector: (err: any, caught: Observable<T>) => ObservableInput<T | R>, private caught: Observable<T>) { super(destination); } error(err: any) { if (!this.isStopped) { let result: any; try { result = this.selector(err, this.caught); } catch (err2) { super.error(err2); return; } this._unsubscribeAndRecycle(); const innerSubscriber = new InnerSubscriber(this, undefined, undefined); this.add(innerSubscriber); subscribeToResult(this, result, undefined, undefined, innerSubscriber); } } }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'KYD': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { ApplicationRef } from './application_ref'; import { IterableDiffers, KeyValueDiffers } from './change_detection/change_detection'; import { StaticProvider } from './di'; export declare function _iterableDiffersFactory(): IterableDiffers; export declare function _keyValueDiffersFactory(): KeyValueDiffers; export declare function _localeFactory(locale?: string): string; export declare const APPLICATION_MODULE_PROVIDERS: StaticProvider[]; export declare class ApplicationModule { constructor(appRef: ApplicationRef); }
export * from 'rxjs-compat/operators/count';
import 'rxjs-compat/add/observable/fromEvent';
import { Component } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css'] }) export class AppComponent { title = 'tsDataset'; }
import 'rxjs-compat/add/operator/switchMapTo';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'BMD': string[]; 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { Config } from './config'; export declare enum LogLevel { ERROR = 0, WARN = 1, INFO = 2, DEBUG = 3, } export declare enum WriteTo { CONSOLE = 0, FILE = 1, BOTH = 2, NONE = 3, } export declare class Logger { private id; static logLevel: LogLevel; static showTimestamp: boolean; static showId: boolean; static writeTo: WriteTo; static fd: any; static firstWrite: boolean; static set(config: Config): void; static setWrite(writeTo: WriteTo, opt_logFile?: string): void; constructor(id: string); info(...msgs: any[]): void; debug(...msgs: any[]): void; warn(...msgs: any[]): void; error(...msgs: any[]): void; log_(logLevel: LogLevel, msgs: any[]): void; print_(logLevel: LogLevel, msgs: any[]): void; static timestamp_(writeTo: WriteTo): string; static id_(logLevel: LogLevel, id: string, writeTo: WriteTo): string; static level_(logLevel: LogLevel, id: string, writeTo: WriteTo): string; static msgToFile_(msgs: any[]): string; }
import 'rxjs-compat/add/operator/combineAll';
import { StaticProvider } from '@angular/core'; export declare const INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS: StaticProvider[];
import { ISemVerDSL } from 'semver-dsl'; export declare const SemVerDSL: ISemVerDSL;
export { InjectableDef as ɵInjectableDef, InjectorDef as ɵInjectorDef, defineInjectable, defineInjector } from './di/defs'; export { inject } from './di/injector'; export { NgModuleDef as ɵNgModuleDef, NgModuleDefWithMeta as ɵNgModuleDefWithMeta } from './metadata/ng_module'; export { defineNgModule as ɵdefineNgModule } from './render3/definition'; export { NgModuleFactory as ɵNgModuleFactory } from './render3/ng_module_ref'; export declare const ITS_JUST_ANGULAR = true;
declare const _default: never[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'DOP': string[]; 'ESP': string[]; 'EUR': (string | undefined)[]; 'FKP': (string | undefined)[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NZD': (string | undefined)[]; 'RON': (string | undefined)[]; 'SSP': (string | undefined)[]; 'SYP': (string | undefined)[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'VEF': (string | undefined)[]; 'VND': (string | undefined)[]; 'XAF': never[]; 'XCD': (string | undefined)[]; 'XOF': never[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/operators/reduce';
export * from './src/api'; export { IvyCompilation } from './src/compilation'; export { DtsFileTransformer } from './src/declaration'; export { ivyTransformFactory } from './src/transform';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'ESP': string[]; 'EUR': (string | undefined)[]; 'FKP': (string | undefined)[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NZD': (string | undefined)[]; 'PYG': string[]; 'RON': (string | undefined)[]; 'SSP': (string | undefined)[]; 'SYP': (string | undefined)[]; 'TWD': (string | undefined)[]; 'USD': (string | undefined)[]; 'VEF': (string | undefined)[]; 'VND': (string | undefined)[]; 'XAF': never[]; 'XCD': (string | undefined)[]; 'XOF': never[]; } | undefined)[]; export default _default;
import { Operator } from '../Operator'; import { Subscriber } from '../Subscriber'; import { tryCatch } from '../util/tryCatch'; import { errorObject } from '../util/errorObject'; import { Observable } from '../Observable'; import { MonoTypeOperatorFunction, TeardownLogic } from '../types'; export function distinctUntilChanged<T>(compare?: (x: T, y: T) => boolean): MonoTypeOperatorFunction<T>; export function distinctUntilChanged<T, K>(compare: (x: K, y: K) => boolean, keySelector: (x: T) => K): MonoTypeOperatorFunction<T>; export function distinctUntilChanged<T, K>(compare?: (x: K, y: K) => boolean, keySelector?: (x: T) => K): MonoTypeOperatorFunction<T> { return (source: Observable<T>) => source.lift(new DistinctUntilChangedOperator<T, K>(compare, keySelector)); } class DistinctUntilChangedOperator<T, K> implements Operator<T, T> { constructor(private compare: (x: K, y: K) => boolean, private keySelector: (x: T) => K) { } call(subscriber: Subscriber<T>, source: any): TeardownLogic { return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector)); } } class DistinctUntilChangedSubscriber<T, K> extends Subscriber<T> { private key: K; private hasKey: boolean = false; constructor(destination: Subscriber<T>, compare: (x: K, y: K) => boolean, private keySelector: (x: T) => K) { super(destination); if (typeof compare === 'function') { this.compare = compare; } } private compare(x: any, y: any): boolean { return x === y; } protected _next(value: T): void { const keySelector = this.keySelector; let key: any = value; if (keySelector) { key = tryCatch(this.keySelector)(value); if (key === errorObject) { return this.destination.error(errorObject.e); } } let result: any = false; if (this.hasKey) { result = tryCatch(this.compare)(this.key, key); if (result === errorObject) { return this.destination.error(errorObject.e); } } else { this.hasKey = true; } if (Boolean(result) === false) { this.key = key; this.destination.next(value); } } }
import { Component } from '@angular/core'; @Component({ selector: '<%= selector %>',<% if(inlineTemplate) { %> template: ` <!--The content below is only a placeholder and can be replaced.--> <div style="text-align:center"> <h1> Welcome to {{title}}! </h1> <img width="300" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTAgMjUwIj4KICAgIDxwYXRoIGZpbGw9IiNERDAwMzEiIGQ9Ik0xMjUgMzBMMzEuOSA2My4ybDE0LjIgMTIzLjFMMTI1IDIzMGw3OC45LTQzLjcgMTQuMi0xMjMuMXoiIC8+CiAgICA8cGF0aCBmaWxsPSIjQzMwMDJGIiBkPSJNMTI1IDMwdjIyLjItLjFWMjMwbDc4LjktNDMuNyAxNC4yLTEyMy4xTDEyNSAzMHoiIC8+CiAgICA8cGF0aCAgZmlsbD0iI0ZGRkZGRiIgZD0iTTEyNSA1Mi4xTDY2LjggMTgyLjZoMjEuN2wxMS43LTI5LjJoNDkuNGwxMS43IDI5LjJIMTgzTDEyNSA1Mi4xem0xNyA4My4zaC0zNGwxNy00MC45IDE3IDQwLjl6IiAvPgogIDwvc3ZnPg=="> </div> <h2>Here are some links to help you start: </h2> <ul> <li> <h2><a target="_blank" rel="noopener" href="https: </li> <li> <h2><a target="_blank" rel="noopener" href="https: </li> <li> <h2><a target="_blank" rel="noopener" href="https: </li> </ul> <% if (routing) { %><router-outlet></router-outlet><% } %> `,<% } else { %> templateUrl: './app.component.html',<% } if(inlineStyle) { %> styles: []<% } else { %> styleUrls: ['./app.component.<%= styleext %>']<% } %> }) export class AppComponent { title = '<%= name %>'; }
export * from 'rxjs-compat/observable/dom/ajax';
export * from 'rxjs-compat/operator/elementAt';
import { Type } from '@angular/core'; export declare function invalidPipeArgumentError(type: Type<any>, value: Object): Error;
import 'rxjs-compat/add/operator/mapTo';
import { ResourceLoader } from '@angular/compiler'; export declare class MockResourceLoader extends ResourceLoader { private _expectations; private _definitions; private _requests; get(url: string): Promise<string>; hasPendingRequests(): boolean; expect(url: string, response: string): void; when(url: string, response: string): void; flush(): void; verifyNoOutstandingExpectations(): void; private _processRequest; }
export declare function devModeEqual(a: any, b: any): boolean; export declare class WrappedValue { wrapped: any; constructor(value: any); static wrap(value: any): WrappedValue; static unwrap(value: any): any; static isWrapped(value: any): value is WrappedValue; } export declare class SimpleChange { previousValue: any; currentValue: any; firstChange: boolean; constructor(previousValue: any, currentValue: any, firstChange: boolean); isFirstChange(): boolean; } export declare function isListLikeIterable(obj: any): boolean; export declare function areIterablesEqual(a: any, b: any, comparator: (a: any, b: any) => boolean): boolean; export declare function iterateListLike(obj: any, fn: (p: any) => any): void; export declare function isJsObject(o: any): boolean;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; 'XCD': string[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
import { Operator } from '../Operator'; import { Subscriber } from '../Subscriber'; import { Observable } from '../Observable'; import { OperatorFunction } from '../types'; export function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> { return function mapOperation(source: Observable<T>): Observable<R> { if (typeof project !== 'function') { throw new TypeError('argument is not a function. Are you looking for `mapTo()`?'); } return source.lift(new MapOperator(project, thisArg)); }; } export class MapOperator<T, R> implements Operator<T, R> { constructor(private project: (value: T, index: number) => R, private thisArg: any) { } call(subscriber: Subscriber<R>, source: any): any { return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg)); } } class MapSubscriber<T, R> extends Subscriber<T> { count: number = 0; private thisArg: any; constructor(destination: Subscriber<R>, private project: (value: T, index: number) => R, thisArg: any) { super(destination); this.thisArg = thisArg || this; } protected _next(value: T) { let result: any; try { result = this.project.call(this.thisArg, value, this.count++); } catch (err) { this.destination.error(err); return; } this.destination.next(result); } }
export * from 'rxjs-compat/operator/throttleTime';
export * from 'rxjs-compat/Notification';
export * from './public_api';
export * from 'rxjs-compat/operators/distinctUntilChanged';
declare const _default: never[]; export default _default;
export declare enum SecurityContext { NONE = 0, HTML = 1, STYLE = 2, SCRIPT = 3, URL = 4, RESOURCE_URL = 5 } export declare abstract class Sanitizer { abstract sanitize(context: SecurityContext, value: {} | string | null): string | null; }
export * from 'rxjs-compat/operators/skipWhile';
Zone.__load_patch('cordova', (global: any, Zone: ZoneType, api: _ZonePrivate) => { if (global.cordova) { const SUCCESS_SOURCE = 'cordova.exec.success'; const ERROR_SOURCE = 'cordova.exec.error'; const FUNCTION = 'function'; const nativeExec: Function|null = api.patchMethod(global.cordova, 'exec', () => function(self: any, args: any[]) { if (args.length > 0 && typeof args[0] === FUNCTION) { args[0] = Zone.current.wrap(args[0], SUCCESS_SOURCE); } if (args.length > 1 && typeof args[1] === FUNCTION) { args[1] = Zone.current.wrap(args[1], ERROR_SOURCE); } return nativeExec!.apply(self, args); }); } }); Zone.__load_patch('cordova.FileReader', (global: any, Zone: ZoneType) => { if (global.cordova && typeof global['FileReader'] !== 'undefined') { document.addEventListener('deviceReady', () => { const FileReader = global['FileReader']; ['abort', 'error', 'load', 'loadstart', 'loadend', 'progress'].forEach(prop => { const eventNameSymbol = Zone.__symbol__('ON_PROPERTY' + prop); Object.defineProperty(FileReader.prototype, eventNameSymbol, { configurable: true, get: function() { return this._realReader && this._realReader[eventNameSymbol]; } }); }); }); } });
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'GNF': string[]; 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { CustomReporterResult } from "../../spec-reporter"; import { DisplayProcessor } from "../display-processor"; export declare class SpecPrefixesProcessor extends DisplayProcessor { displaySuccessfulSpec(spec: CustomReporterResult, log: String): String; displayFailedSpec(spec: CustomReporterResult, log: String): String; displayPendingSpec(spec: CustomReporterResult, log: String): String; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import { ArchitectCommand, ArchitectCommandOptions } from '../models/architect-command'; import { Arguments } from '../models/interface'; import { Schema as ServeCommandSchema } from './serve'; export declare class ServeCommand extends ArchitectCommand<ServeCommandSchema> { readonly target = "serve"; validate(_options: ArchitectCommandOptions & Arguments): boolean; run(options: ArchitectCommandOptions & Arguments): Promise<number>; }
export * from './public_api';
import { MonoTypeOperatorFunction } from '../types'; export declare const throwIfEmpty: <T>(errorFactory?: () => any) => MonoTypeOperatorFunction<T>;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import { DirectiveDef } from '../interfaces/definition'; export declare function NgOnChangesFeature<T>(definition: DirectiveDef<T>): void;
import './ng_dev_mode'; import { LContext } from './interfaces/context'; import { LViewData } from './interfaces/view'; export declare function getContext(target: any): LContext | null; export declare function getComponentViewByInstance(componentInstance: {}): LViewData; export declare function attachPatchData(target: any, data: LViewData | LContext): void; export declare function isComponentInstance(instance: any): boolean; export declare function isDirectiveInstance(instance: any): boolean; export declare function discoverDirectives(nodeIndex: number, lViewData: LViewData, includeComponents: boolean): any[] | null; export declare function discoverLocalRefs(lViewData: LViewData, nodeIndex: number): { [key: string]: any; } | null;
export * from 'rxjs-compat/operators/elementAt';
export * from 'rxjs-compat/operators/observeOn';
import * as q from 'q'; import { Config } from '../config'; import { DriverProvider } from './driverProvider'; export declare class Kobiton extends DriverProvider { constructor(config: Config); protected setupDriverEnv(): q.Promise<any>; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AOA': never[]; 'ARS': never[]; 'AUD': never[]; 'BAM': never[]; 'BBD': never[]; 'BDT': never[]; 'BMD': never[]; 'BND': never[]; 'BOB': never[]; 'BRL': never[]; 'BSD': never[]; 'BWP': never[]; 'BYN': never[]; 'BZD': never[]; 'CAD': never[]; 'CLP': never[]; 'CNY': never[]; 'COP': never[]; 'CRC': never[]; 'CUC': never[]; 'CUP': never[]; 'CZK': never[]; 'DKK': never[]; 'DOP': never[]; 'EGP': never[]; 'ESP': never[]; 'FIM': string[]; 'FJD': never[]; 'FKP': never[]; 'GEL': never[]; 'GIP': never[]; 'GNF': never[]; 'GTQ': never[]; 'GYD': never[]; 'HKD': never[]; 'HNL': never[]; 'HRK': never[]; 'HUF': never[]; 'IDR': never[]; 'ILS': never[]; 'INR': never[]; 'ISK': never[]; 'JMD': never[]; 'KHR': never[]; 'KMF': never[]; 'KPW': never[]; 'KRW': never[]; 'KYD': never[]; 'KZT': never[]; 'LAK': never[]; 'LBP': never[]; 'LKR': never[]; 'LRD': never[]; 'LTL': never[]; 'LVL': never[]; 'MGA': never[]; 'MMK': never[]; 'MNT': never[]; 'MUR': never[]; 'MXN': never[]; 'MYR': never[]; 'NAD': never[]; 'NGN': never[]; 'NIO': never[]; 'NOK': never[]; 'NPR': never[]; 'NZD': never[]; 'PHP': never[]; 'PKR': never[]; 'PLN': never[]; 'PYG': never[]; 'RON': never[]; 'RUR': never[]; 'RWF': never[]; 'SBD': never[]; 'SEK': never[]; 'SGD': never[]; 'SHP': never[]; 'SRD': never[]; 'SSP': never[]; 'STN': (string | undefined)[]; 'SYP': never[]; 'THB': never[]; 'TOP': never[]; 'TRY': never[]; 'TTD': never[]; 'TWD': never[]; 'UAH': never[]; 'UYU': never[]; 'VEF': never[]; 'VND': never[]; 'XCD': never[]; 'XPF': never[]; 'ZAR': never[]; 'ZMW': never[]; } | undefined)[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { OperatorFunction } from '../types'; export declare function pairwise<T>(): OperatorFunction<T, [T, T]>;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export interface Schema { configuration?: string; help?: HelpUnion; prod?: boolean; project?: string; } export declare type HelpUnion = boolean | HelpEnum; export declare enum HelpEnum { HelpJSON = "JSON", JSON = "json" }
export * from 'rxjs-compat/util/toSubscriber';
export * from 'rxjs-compat/operator/elementAt';
import { StaticSymbolResolverHost } from './static_symbol_resolver'; import { AotSummaryResolverHost } from './summary_resolver'; export interface AotCompilerHost extends StaticSymbolResolverHost, AotSummaryResolverHost { fileNameToModuleName(importedFilePath: string, containingFilePath: string): string; resourceNameToFileName(resourceName: string, containingFileName: string): string | null; loadResource(path: string): Promise<string> | string; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.OptionallyTypedRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING_ALPHABETICAL(name: string): string; static FAILURE_STRING_USE_DECLARATION_ORDER(propName: string, typeName: string | undefined): string; static FAILURE_STRING_SHORTHAND_FIRST(name: string): string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): Lint.RuleFailure[]; }
export interface AnimationPlayer { onDone(fn: () => void): void; onStart(fn: () => void): void; onDestroy(fn: () => void): void; init(): void; hasStarted(): boolean; play(): void; pause(): void; restart(): void; finish(): void; destroy(): void; reset(): void; setPosition(position: any ): void; getPosition(): number; parentPlayer: AnimationPlayer | null; readonly totalTime: number; beforeDestroy?: () => any; } export declare class NoopAnimationPlayer implements AnimationPlayer { private _onDoneFns; private _onStartFns; private _onDestroyFns; private _started; private _destroyed; private _finished; parentPlayer: AnimationPlayer | null; readonly totalTime: number; constructor(duration?: number, delay?: number); private _onFinish; onStart(fn: () => void): void; onDone(fn: () => void): void; onDestroy(fn: () => void): void; hasStarted(): boolean; init(): void; play(): void; private _onStart; pause(): void; restart(): void; finish(): void; destroy(): void; reset(): void; setPosition(position: number): void; getPosition(): number; }
export * from 'rxjs-compat/observable/SubscribeOnObservable';
export * from 'rxjs-compat/operator/pairwise';
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING_AS_NEEDED: string; static FAILURE_STRING_FACTORY(kind: string): string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import { AST } from '../../expression_parser/ast'; import { BoundAttribute, BoundEvent, Element, Node, Reference, Template, TextAttribute, Variable } from '../r3_ast'; export interface Target { template?: Node[]; } export interface DirectiveMeta { name: string; isComponent: boolean; inputs: { [property: string]: string | [string, string]; }; outputs: { [property: string]: string; }; exportAs: string | null; } export interface TargetBinder<D extends DirectiveMeta> { bind(target: Target): BoundTarget<D>; } export interface BoundTarget<DirectiveT extends DirectiveMeta> { readonly target: Target; getDirectivesOfNode(node: Element | Template): DirectiveT[] | null; getReferenceTarget(ref: Reference): { directive: DirectiveT; node: Element | Template; } | Element | Template | null; getConsumerOfBinding(binding: BoundAttribute | BoundEvent | TextAttribute): DirectiveT | Element | Template | null; getExpressionTarget(expr: AST): Reference | Variable | null; getTemplateOfSymbol(symbol: Reference | Variable): Template | null; getNestingLevel(template: Template): number; getUsedDirectives(): DirectiveT[]; }
declare const win: any; export { win as window };
import 'rxjs-compat/add/operator/last';
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; } export declare const IRREGULAR_WHITESPACE_REGEX: RegExp;
import * as ts from "typescript"; import { RuleFailure } from "./language/rule/rule"; export declare const ENABLE_DISABLE_REGEX: RegExp; export declare function removeDisabledFailures(sourceFile: ts.SourceFile, failures: RuleFailure[]): RuleFailure[];
import * as ts from "typescript"; import { Location, Privacy } from "../completedDocsRule"; import { Exclusion } from "./exclusion"; export interface IClassExclusionDescriptor { locations?: Location[]; privacies?: Privacy[]; } export declare class ClassExclusion extends Exclusion<IClassExclusionDescriptor> { readonly locations: Set<Location>; readonly privacies: Set<Privacy>; excludes(node: ts.Node): boolean; private shouldLocationBeDocumented; private shouldPrivacyBeDocumented; }
export declare const codeExamples: { description: string; config: string; pass: string; fail: string; }[];
export * from './src/upgrade';
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare const _default: never[]; export default _default;
declare const _default: (string[][] | undefined)[]; export default _default;
export declare class PlaceholderRegistry { private _placeHolderNameCounts; private _signatureToName; getStartTagPlaceholderName(tag: string, attrs: { [k: string]: string; }, isVoid: boolean): string; getCloseTagPlaceholderName(tag: string): string; getPlaceholderName(name: string, content: string): string; getUniquePlaceholder(name: string): string; private _hashTag; private _hashClosingTag; private _generateUniqueName; }
export * from './testing/testing';
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare const _default: never[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import * as ts from 'typescript'; import MagicString from 'magic-string'; import { NgccReflectionHost, SwitchableVariableDeclaration } from '../host/ngcc_host'; import { AnalyzedClass } from '../analysis/decoration_analyzer'; import { Renderer } from './renderer'; export declare class Fesm2015Renderer extends Renderer { protected host: NgccReflectionHost; protected isCore: boolean; protected rewriteCoreImportsTo: ts.SourceFile | null; protected sourcePath: string; protected targetPath: string; constructor(host: NgccReflectionHost, isCore: boolean, rewriteCoreImportsTo: ts.SourceFile | null, sourcePath: string, targetPath: string); addImports(output: MagicString, imports: { name: string; as: string; }[]): void; addConstants(output: MagicString, constants: string, file: ts.SourceFile): void; addDefinitions(output: MagicString, analyzedClass: AnalyzedClass, definitions: string): void; removeDecorators(output: MagicString, decoratorsToRemove: Map<ts.Node, ts.Node[]>): void; rewriteSwitchableDeclarations(outputText: MagicString, sourceFile: ts.SourceFile, declarations: SwitchableVariableDeclaration[]): void; }
import { AbstractFormatter } from "../language/formatter/abstractFormatter"; import { IFormatterMetadata } from "../language/formatter/formatter"; import { RuleFailure } from "../language/rule/rule"; export declare class Formatter extends AbstractFormatter { static metadata: IFormatterMetadata; format(failures: RuleFailure[]): string; private escapeXml; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING_MISSING: string; static FAILURE_STRING_COMMA: string; static FAILURE_STRING_TRAILING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
export { AnimationDriver } from './render/animation_driver'; export * from './private_export';
export declare function findUp(names: string | string[], from: string, stopOnNodeModules?: boolean): string | null;
import { Path, virtualFs } from '@angular-devkit/core'; import { Observable } from 'rxjs'; import { CreateFileAction } from '../tree/action'; import { UpdateBuffer } from '../utility/update-buffer'; import { SimpleSinkBase } from './sink'; export declare class HostSink extends SimpleSinkBase { protected _host: virtualFs.Host; protected _force: boolean; protected _filesToDelete: Set<Path>; protected _filesToRename: Set<[Path, Path]>; protected _filesToCreate: Map<Path, UpdateBuffer>; protected _filesToUpdate: Map<Path, UpdateBuffer>; constructor(_host: virtualFs.Host, _force?: boolean); protected _validateCreateAction(action: CreateFileAction): Observable<void>; protected _validateFileExists(p: Path): Observable<boolean>; protected _overwriteFile(path: Path, content: Buffer): Observable<void>; protected _createFile(path: Path, content: Buffer): Observable<void>; protected _renameFile(from: Path, to: Path): Observable<void>; protected _deleteFile(path: Path): Observable<void>; _done(): Observable<void>; }
import { UrlTree } from './url_tree'; export declare abstract class UrlHandlingStrategy { abstract shouldProcessUrl(url: UrlTree): boolean; abstract extract(url: UrlTree): UrlTree; abstract merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree; } export declare class DefaultUrlHandlingStrategy implements UrlHandlingStrategy { shouldProcessUrl(url: UrlTree): boolean; extract(url: UrlTree): UrlTree; merge(newUrlPart: UrlTree, wholeUrl: UrlTree): UrlTree; }
export * from './src/index';
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.TypedRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): Lint.RuleFailure[]; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; isEnabled(): boolean; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
export * from './webpack'; export * from './webpack-dev-server';
import { Source } from '../engine/interface'; export interface RandomOptions { root?: string; multi?: boolean | number; multiFiles?: boolean | number; } export default function (options: RandomOptions): Source;
import { Injector } from '@angular/core'; import { ChildrenOutletContexts } from '../router_outlet_context'; import { ActivatedRouteSnapshot, RouterStateSnapshot } from '../router_state'; export declare class CanActivate { path: ActivatedRouteSnapshot[]; readonly route: ActivatedRouteSnapshot; constructor(path: ActivatedRouteSnapshot[]); } export declare class CanDeactivate { component: Object | null; route: ActivatedRouteSnapshot; constructor(component: Object | null, route: ActivatedRouteSnapshot); } export declare type Checks = { canDeactivateChecks: CanDeactivate[]; canActivateChecks: CanActivate[]; }; export declare function getAllRouteGuards(future: RouterStateSnapshot, curr: RouterStateSnapshot, parentContexts: ChildrenOutletContexts): Checks; export declare function getCanActivateChild(p: ActivatedRouteSnapshot): { node: ActivatedRouteSnapshot; guards: any[]; } | null; export declare function getToken(token: any, snapshot: ActivatedRouteSnapshot, moduleInjector: Injector): any;
import { AnimationMetadata, AnimationOptions, AnimationPlayer } from '@angular/animations'; import { AnimationStyleNormalizer } from '../dsl/style_normalization/animation_style_normalizer'; import { AnimationDriver } from './animation_driver'; export declare class TimelineAnimationEngine { bodyNode: any; private _driver; private _normalizer; private _animations; private _playersById; players: AnimationPlayer[]; constructor(bodyNode: any, _driver: AnimationDriver, _normalizer: AnimationStyleNormalizer); register(id: string, metadata: AnimationMetadata | AnimationMetadata[]): void; private _buildPlayer; create(id: string, element: any, options?: AnimationOptions): AnimationPlayer; destroy(id: string): void; private _getPlayer; listen(id: string, element: string, eventName: string, callback: (event: any) => any): () => void; command(id: string, element: any, command: string, args: any[]): void; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
export {};
import * as webpack from 'webpack'; import { WebpackConfigOptions, WebpackTestOptions } from '../build-options'; export declare function getTestConfig(wco: WebpackConfigOptions<WebpackTestOptions>): webpack.Configuration;
import { ConstantPool } from '@angular/compiler'; import * as ts from 'typescript'; import { ResourceLoader, SelectorScopeRegistry } from '../../../ngtsc/annotations'; import { CompileResult, DecoratorHandler } from '../../../ngtsc/transform'; import { DecoratedClass } from '../host/decorated_class'; import { DecoratedFile } from '../host/decorated_file'; import { NgccReflectionHost } from '../host/ngcc_host'; export interface AnalyzedClass<A = any, M = any> extends DecoratedClass { handler: DecoratorHandler<A, M>; analysis: any; diagnostics?: ts.Diagnostic[]; compilation: CompileResult[]; } export interface DecorationAnalysis { analyzedClasses: AnalyzedClass[]; sourceFile: ts.SourceFile; constantPool: ConstantPool; } export declare type DecorationAnalyses = Map<ts.SourceFile, DecorationAnalysis>; export declare const DecorationAnalyses: MapConstructor; export interface MatchingHandler<A, M> { handler: DecoratorHandler<A, M>; match: M; } export declare class FileResourceLoader implements ResourceLoader { load(url: string): string; } export declare class DecorationAnalyzer { private typeChecker; private host; private rootDirs; private isCore; resourceLoader: FileResourceLoader; scopeRegistry: SelectorScopeRegistry; handlers: DecoratorHandler<any, any>[]; constructor(typeChecker: ts.TypeChecker, host: NgccReflectionHost, rootDirs: string[], isCore: boolean); analyzeProgram(program: ts.Program): DecorationAnalyses; protected analyzeFile(file: DecoratedFile): DecorationAnalysis; protected analyzeClass(pool: ConstantPool, clazz: DecoratedClass): AnalyzedClass | undefined; }
import * as ts from "typescript"; export declare const typeIsOrHasBaseType: (type: ts.Type, parentType: ts.Type) => boolean;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export * from './testing/testing';
export * from './public_api';
declare const _default: never[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import { CompileReflector } from './compile_reflector'; import { Directive, Type } from './core'; export declare class DirectiveResolver { private _reflector; constructor(_reflector: CompileReflector); isDirective(type: Type): boolean; resolve(type: Type): Directive; resolve(type: Type, throwIfNotFound: true): Directive; resolve(type: Type, throwIfNotFound: boolean): Directive | null; private _mergeWithPropertyMetadata; private _extractPublicName; private _dedupeBindings; private _merge; } export declare function findLast<T>(arr: T[], condition: (value: T) => boolean): T | null;
import { InjectionToken, NgZone } from '@angular/core'; export declare const EVENT_MANAGER_PLUGINS: InjectionToken<EventManagerPlugin[]>; export declare class EventManager { private _zone; private _plugins; private _eventNameToPlugin; constructor(plugins: EventManagerPlugin[], _zone: NgZone); addEventListener(element: HTMLElement, eventName: string, handler: Function): Function; addGlobalEventListener(target: string, eventName: string, handler: Function): Function; getZone(): NgZone; } export declare abstract class EventManagerPlugin { private _doc; constructor(_doc: any); manager: EventManager; abstract supports(eventName: string): boolean; abstract addEventListener(element: HTMLElement, eventName: string, handler: Function): Function; addGlobalEventListener(element: string, eventName: string, handler: Function): Function; }
declare const _default: never[]; export default _default;
declare const _default: never[]; export default _default;
export declare const rules: { "align": { options: string[]; }; "no-invalid-template-strings": boolean; "no-sparse-arrays": boolean; "no-object-literal-type-assertion": boolean; "prefer-conditional-expression": boolean; "prefer-object-spread": boolean; "no-duplicate-variable": (string | boolean)[]; "no-this-assignment": boolean; "no-duplicate-imports": boolean; "space-within-parens": (number | boolean)[]; "no-submodule-imports": boolean; "whitespace": { options: string[]; }; "ban-comma-operator": boolean; "jsdoc-format": { options: string; }; "no-duplicate-switch-case": boolean; "no-implicit-dependencies": boolean; "no-return-await": boolean; }; declare const xtends = "tslint:recommended"; export { xtends as extends };
import * as ts from "typescript"; import * as Lint from ".."; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING_OUTSIDE: string; static FAILURE_STRING_INSIDE: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import { AbstractFormatter } from "../language/formatter/abstractFormatter"; import { IFormatterMetadata } from "../language/formatter/formatter"; import { RuleFailure } from "../language/rule/rule"; export declare class Formatter extends AbstractFormatter { static metadata: IFormatterMetadata; format(failures: RuleFailure[]): string; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
export { BrowserModule, platformBrowser } from './browser'; export { Meta, MetaDefinition } from './browser/meta'; export { Title } from './browser/title'; export { disableDebugTools, enableDebugTools } from './browser/tools/tools'; export { BrowserTransferStateModule, StateKey, TransferState, makeStateKey } from './browser/transfer_state'; export { By } from './dom/debug/by'; export { DOCUMENT } from './dom/dom_tokens'; export { EVENT_MANAGER_PLUGINS, EventManager } from './dom/events/event_manager'; export { HAMMER_GESTURE_CONFIG, HAMMER_LOADER, HammerGestureConfig, HammerLoader } from './dom/events/hammer_gestures'; export { DomSanitizer, SafeHtml, SafeResourceUrl, SafeScript, SafeStyle, SafeUrl, SafeValue } from './security/dom_sanitization_service'; export * from './private_export'; export { VERSION } from './version';
import 'rxjs-compat/add/operator/single';
export * from 'rxjs-compat/operator/windowWhen';
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING_FACTORY(identifier: string, blockScoped: boolean): string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import { ɵStyleData } from '@angular/animations'; import { AnimationEngineInstruction } from '../render/animation_engine_instruction'; export interface AnimationTimelineInstruction extends AnimationEngineInstruction { element: any; keyframes: ɵStyleData[]; preStyleProps: string[]; postStyleProps: string[]; duration: number; delay: number; totalTime: number; easing: string | null; stretchStartingKeyframe?: boolean; subTimeline: boolean; } export declare function createTimelineInstruction(element: any, keyframes: ɵStyleData[], preStyleProps: string[], postStyleProps: string[], duration: number, delay: number, easing?: string | null, subTimeline?: boolean): AnimationTimelineInstruction;
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING_REDUNDANT_TYPE: string; static FAILURE_STRING_REDUNDANT_TAG(tagName: string): string; static FAILURE_STRING_NO_COMMENT(tagName: string): string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
export * from 'rxjs-compat/observable/generate';
export * from 'rxjs-compat/operator/takeLast';
import { TagContentType, TagDefinition } from './tags'; export declare class HtmlTagDefinition implements TagDefinition { private closedByChildren; closedByParent: boolean; requiredParents: { [key: string]: boolean; }; parentToAdd: string; implicitNamespacePrefix: string | null; contentType: TagContentType; isVoid: boolean; ignoreFirstLf: boolean; canSelfClose: boolean; constructor({ closedByChildren, requiredParents, implicitNamespacePrefix, contentType, closedByParent, isVoid, ignoreFirstLf }?: { closedByChildren?: string[]; closedByParent?: boolean; requiredParents?: string[]; implicitNamespacePrefix?: string; contentType?: TagContentType; isVoid?: boolean; ignoreFirstLf?: boolean; }); requireExtraParent(currentParent: string): boolean; isClosedByChild(name: string): boolean; } export declare function getHtmlTagDefinition(tagName: string): HtmlTagDefinition;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/util/isDate';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
declare const _default: never[]; export default _default;
import { Operator } from '../Operator'; import { Observable } from '../Observable'; import { Subscriber } from '../Subscriber'; import { Observer, OperatorFunction } from '../types'; export declare function sequenceEqual<T>(compareTo: Observable<T>, comparor?: (a: T, b: T) => boolean): OperatorFunction<T, boolean>; export declare class SequenceEqualOperator<T> implements Operator<T, boolean> { private compareTo; private comparor; constructor(compareTo: Observable<T>, comparor: (a: T, b: T) => boolean); call(subscriber: Subscriber<boolean>, source: any): any; } export declare class SequenceEqualSubscriber<T, R> extends Subscriber<T> { private compareTo; private comparor; private _a; private _b; private _oneComplete; constructor(destination: Observer<R>, compareTo: Observable<T>, comparor: (a: T, b: T) => boolean); protected _next(value: T): void; _complete(): void; checkValues(): void; emit(value: boolean): void; nextB(value: T): void; completeB(): void; }
export * from 'rxjs-compat/operators/publishReplay';
export * from 'rxjs-compat/operators/every';
import { QueryList } from '../linker/query_list'; import { NodeDef, NodeFlags, QueryBindingType, QueryValueType, ViewData } from './types'; export declare function queryDef(flags: NodeFlags, id: number, bindings: { [propName: string]: QueryBindingType; }): NodeDef; export declare function createQuery(): QueryList<any>; export declare function dirtyParentQueries(view: ViewData): void; export declare function checkAndUpdateQuery(view: ViewData, nodeDef: NodeDef): void; export declare function getQueryValue(view: ViewData, nodeDef: NodeDef, queryValueType: QueryValueType): any;
import { Injectable } from '../../di/injectable'; import { Type } from '../../type'; export declare function compileInjectable(type: Type<any>, srcMeta?: Injectable): void;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': (string | undefined)[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'ESP': string[]; 'EUR': (string | undefined)[]; 'FKP': (string | undefined)[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NZD': (string | undefined)[]; 'RON': (string | undefined)[]; 'SSP': (string | undefined)[]; 'SYP': (string | undefined)[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'VEF': (string | undefined)[]; 'VND': (string | undefined)[]; 'XAF': never[]; 'XCD': (string | undefined)[]; 'XOF': never[]; } | undefined)[]; export default _default;
import {browser, element, by, By, $, $$, ExpectedConditions} from 'protractor'; describe('protractor with typescript typings', () => { beforeEach(() => { browser.get('http: }); it('should greet the named user', () => { element(by.model('yourName')).sendKeys('Julie'); let greeting = element(by.binding('yourName')); expect(greeting.getText()).toEqual('Hello Julie!'); }); it('should list todos', function() { let todoList = element.all(by.repeater('todo in todoList.todos')); expect(todoList.count()).toEqual(2); expect(todoList.get(1).getText()).toEqual('build an angular app'); }); });
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
import { Operator } from '../Operator'; import { Subscriber } from '../Subscriber'; import { Subscription } from '../Subscription'; import { OuterSubscriber } from '../OuterSubscriber'; import { InnerSubscriber } from '../InnerSubscriber'; import { ObservableInput, OperatorFunction } from '../types'; export declare function mergeScan<T, R>(accumulator: (acc: R, value: T) => ObservableInput<R>, seed: R, concurrent?: number): OperatorFunction<T, R>; export declare class MergeScanOperator<T, R> implements Operator<T, R> { private accumulator; private seed; private concurrent; constructor(accumulator: (acc: R, value: T) => ObservableInput<R>, seed: R, concurrent: number); call(subscriber: Subscriber<R>, source: any): any; } export declare class MergeScanSubscriber<T, R> extends OuterSubscriber<T, R> { private accumulator; private acc; private concurrent; private hasValue; private hasCompleted; private buffer; private active; protected index: number; constructor(destination: Subscriber<R>, accumulator: (acc: R, value: T) => ObservableInput<R>, acc: R, concurrent: number); protected _next(value: any): void; private _innerSub; protected _complete(): void; notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void; notifyComplete(innerSub: Subscription): void; }
import { Observable } from '../Observable'; import { ReplaySubject } from '../ReplaySubject'; import { Subscription } from '../Subscription'; import { MonoTypeOperatorFunction, SchedulerLike } from '../types'; import { Subscriber } from '../Subscriber'; export function shareReplay<T>( bufferSize: number = Number.POSITIVE_INFINITY, windowTime: number = Number.POSITIVE_INFINITY, scheduler?: SchedulerLike ): MonoTypeOperatorFunction<T> { return (source: Observable<T>) => source.lift(shareReplayOperator(bufferSize, windowTime, scheduler)); } function shareReplayOperator<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike) { let subject: ReplaySubject<T>; let refCount = 0; let subscription: Subscription; let hasError = false; let isComplete = false; return function shareReplayOperation(this: Subscriber<T>, source: Observable<T>) { refCount++; if (!subject || hasError) { hasError = false; subject = new ReplaySubject<T>(bufferSize, windowTime, scheduler); subscription = source.subscribe({ next(value) { subject.next(value); }, error(err) { hasError = true; subject.error(err); }, complete() { isComplete = true; subject.complete(); }, }); } const innerSub = subject.subscribe(this); return () => { refCount--; innerSub.unsubscribe(); if (subscription && refCount === 0 && isComplete) { subscription.unsubscribe(); } }; }; }
import { Compiler, CompilerOptions, Component, ComponentFactory, Directive, Injector, NgModule, Pipe, Type } from '@angular/core'; import { MetadataOverride } from './metadata_override'; export declare class TestingCompiler extends Compiler { readonly injector: Injector; overrideModule(module: Type<any>, overrides: MetadataOverride<NgModule>): void; overrideDirective(directive: Type<any>, overrides: MetadataOverride<Directive>): void; overrideComponent(component: Type<any>, overrides: MetadataOverride<Component>): void; overridePipe(directive: Type<any>, overrides: MetadataOverride<Pipe>): void; loadAotSummaries(summaries: () => any[]): void; getComponentFactory<T>(component: Type<T>): ComponentFactory<T>; getComponentFromError(error: Error): Type<any> | null; } export declare abstract class TestingCompilerFactory { abstract createTestingCompiler(options?: CompilerOptions[]): TestingCompiler; }
import { JsonAstObject, JsonObject, experimental } from '@angular-devkit/core'; export declare const workspaceSchemaPath: string; export declare function getWorkspace(level?: 'local' | 'global'): experimental.workspace.Workspace | null; export declare function createGlobalSettings(): string; export declare function getWorkspaceRaw(level?: 'local' | 'global'): [JsonAstObject | null, string | null]; export declare function validateWorkspace(json: JsonObject): boolean; export declare function getProjectByCwd(workspace: experimental.workspace.Workspace): string | null; export declare function getPackageManager(): string; export declare function migrateLegacyGlobalConfig(): boolean; export declare function getSchematicDefaults(collection: string, schematic: string, project?: string | null): {}; export declare function isWarningEnabled(warning: string): boolean;
declare const _default: never[]; export default _default;
export * from 'rxjs-compat/operators/scan';
import { RElement } from './renderer'; import { LViewData } from './view'; export declare const MONKEY_PATCH_KEY_NAME = "__ngContext__"; export interface LContext { lViewData: LViewData; nodeIndex: number; native: RElement; component: {} | null | undefined; directives: any[] | null | undefined; localRefs: { [key: string]: any; } | null | undefined; }
declare const _default: never[]; export default _default;
export * from 'rxjs-compat/util/tryCatch';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'PKR': string[]; 'THB': string[]; 'TWD': string[]; } | undefined)[]; export default _default;
import { Operator } from '../Operator'; import { Observable } from '../Observable'; import { Subscriber } from '../Subscriber'; import { OuterSubscriber } from '../OuterSubscriber'; import { InnerSubscriber } from '../InnerSubscriber'; import { subscribeToResult } from '../util/subscribeToResult'; import { MonoTypeOperatorFunction, TeardownLogic } from '../types'; export function takeUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> { return (source: Observable<T>) => source.lift(new TakeUntilOperator(notifier)); } class TakeUntilOperator<T> implements Operator<T, T> { constructor(private notifier: Observable<any>) { } call(subscriber: Subscriber<T>, source: any): TeardownLogic { const takeUntilSubscriber = new TakeUntilSubscriber(subscriber); const notifierSubscription = subscribeToResult(takeUntilSubscriber, this.notifier); if (notifierSubscription && !takeUntilSubscriber.seenValue) { takeUntilSubscriber.add(notifierSubscription); return source.subscribe(takeUntilSubscriber); } return takeUntilSubscriber; } } class TakeUntilSubscriber<T, R> extends OuterSubscriber<T, R> { seenValue = false; constructor(destination: Subscriber<any>, ) { super(destination); } notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void { this.seenValue = true; this.complete(); } notifyComplete(): void { } }
import { Operator } from '../Operator'; import { Subscriber } from '../Subscriber'; import { Observable } from '../Observable'; import { OuterSubscriber } from '../OuterSubscriber'; import { InnerSubscriber } from '../InnerSubscriber'; import { subscribeToResult } from '../util/subscribeToResult'; import { OperatorFunction } from '../types'; export function buffer<T>(closingNotifier: Observable<any>): OperatorFunction<T, T[]> { return function bufferOperatorFunction(source: Observable<T>) { return source.lift(new BufferOperator<T>(closingNotifier)); }; } class BufferOperator<T> implements Operator<T, T[]> { constructor(private closingNotifier: Observable<any>) { } call(subscriber: Subscriber<T[]>, source: any): any { return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier)); } } class BufferSubscriber<T> extends OuterSubscriber<T, any> { private buffer: T[] = []; constructor(destination: Subscriber<T[]>, closingNotifier: Observable<any>) { super(destination); this.add(subscribeToResult(this, closingNotifier)); } protected _next(value: T) { this.buffer.push(value); } notifyNext(outerValue: T, innerValue: any, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, any>): void { const buffer = this.buffer; this.buffer = []; this.destination.next(buffer); } }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import { OnDestroy, OnInit } from '@angular/core'; import { FormArray } from '../../model'; import { AbstractFormGroupDirective } from '../abstract_form_group_directive'; import { ControlContainer } from '../control_container'; import { AsyncValidatorFn, ValidatorFn } from '../validators'; import { FormGroupDirective } from './form_group_directive'; export declare const formGroupNameProvider: any; export declare class FormGroupName extends AbstractFormGroupDirective implements OnInit, OnDestroy { name: string; constructor(parent: ControlContainer, validators: any[], asyncValidators: any[]); } export declare const formArrayNameProvider: any; export declare class FormArrayName extends ControlContainer implements OnInit, OnDestroy { name: string; constructor(parent: ControlContainer, validators: any[], asyncValidators: any[]); ngOnInit(): void; ngOnDestroy(): void; readonly control: FormArray; readonly formDirective: FormGroupDirective | null; readonly path: string[]; readonly validator: ValidatorFn | null; readonly asyncValidator: AsyncValidatorFn | null; private _checkParentType; }
type EventNames<T extends string | symbol | { [K in string | symbol]: any[] }> = T extends string | symbol ? T : keyof T; type EventArgs<T extends string | symbol | { [K in string | symbol]: any[] }, K extends EventNames<T>> = T extends string | symbol ? any[] : K extends keyof T ? T[K] : never; declare class EventEmitter<EventTypes extends string | symbol | { [K in keyof EventTypes]: any[] } = string | symbol> { static prefixed: string | boolean; eventNames(): Array<EventNames<EventTypes>>; listeners<T extends EventNames<EventTypes>>(event: T): Array<EventEmitter.ListenerFn<EventArgs<EventTypes, T>>>; listenerCount(event: EventNames<EventTypes>): number; emit<T extends EventNames<EventTypes>>(event: T, ...args: EventArgs<EventTypes, T>): boolean; on<T extends EventNames<EventTypes>>(event: T, fn: EventEmitter.ListenerFn<EventArgs<EventTypes, T>>, context?: any): this; addListener<T extends EventNames<EventTypes>>(event: T, fn: EventEmitter.ListenerFn<EventArgs<EventTypes, T>>, context?: any): this; once<T extends EventNames<EventTypes>>(event: T, fn: EventEmitter.ListenerFn<EventArgs<EventTypes, T>>, context?: any): this; removeListener<T extends EventNames<EventTypes>>(event: T, fn?: EventEmitter.ListenerFn<EventArgs<EventTypes, T>>, context?: any, once?: boolean): this; off<T extends EventNames<EventTypes>>(event: T, fn?: EventEmitter.ListenerFn<EventArgs<EventTypes, T>>, context?: any, once?: boolean): this; removeAllListeners(event?: EventNames<EventTypes>): this; } declare namespace EventEmitter { export interface ListenerFn<Args extends any[] = any[]> { (...args: Args): void; } export interface EventEmitterStatic { new<EventTypes extends string | symbol | { [K in keyof EventTypes]: any[] } = string | symbol>(): EventEmitter<EventTypes>; } export const EventEmitter: EventEmitterStatic; } export = EventEmitter;
export interface HttpParameterCodec { encodeKey(key: string): string; encodeValue(value: string): string; decodeKey(key: string): string; decodeValue(value: string): string; } export declare class HttpUrlEncodingCodec implements HttpParameterCodec { encodeKey(key: string): string; encodeValue(value: string): string; decodeKey(key: string): string; decodeValue(value: string): string; } export interface HttpParamsOptions { fromString?: string; fromObject?: { [param: string]: string | string[]; }; encoder?: HttpParameterCodec; } export declare class HttpParams { private map; private encoder; private updates; private cloneFrom; constructor(options?: HttpParamsOptions); has(param: string): boolean; get(param: string): string | null; getAll(param: string): string[] | null; keys(): string[]; append(param: string, value: string): HttpParams; set(param: string, value: string): HttpParams; delete(param: string, value?: string): HttpParams; toString(): string; private clone; private init; }
export * from 'rxjs-compat/observable/GenerateObservable';
export * from './opts';
import 'rxjs-compat/add/operator/switch';
import { Subscriber } from '../../Subscriber'; import { AjaxResponse } from './AjaxObservable'; export class AjaxRequestDoc { url: string = ''; body: any = 0; user: string = ''; async: boolean = false; method: string = ''; headers: Object = null; timeout: number = 0; password: string = ''; hasContent: boolean = false; crossDomain: boolean = false; withCredentials: boolean = false; createXHR(): XMLHttpRequest { return null; } progressSubscriber: Subscriber<any> = null; resultSelector<T>(response: AjaxResponse): T { return null; } responseType: string = ''; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'MYR': string[]; 'SGD': string[]; 'THB': string[]; 'TWD': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { InjectionToken } from './injection_token'; export declare const APP_ROOT: InjectionToken<boolean>;
import { reduce } from './reduce'; import { OperatorFunction } from '../types'; function toArrayReducer<T>(arr: T[], item: T, index: number) { if (index === 0) { return [item]; } arr.push(item); return arr; } export function toArray<T>(): OperatorFunction<T, T[]> { return reduce(toArrayReducer, []) as OperatorFunction<T, T[]>; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'CDF': string[]; 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { BundlePrivateEntry } from './bundler'; export declare function privateEntriesToIndex(index: string, privates: BundlePrivateEntry[]): string;
import { InjectionToken } from '@angular/core'; export declare abstract class PlatformLocation { abstract getBaseHrefFromDOM(): string; abstract onPopState(fn: LocationChangeListener): void; abstract onHashChange(fn: LocationChangeListener): void; abstract readonly pathname: string; abstract readonly search: string; abstract readonly hash: string; abstract replaceState(state: any, title: string, url: string): void; abstract pushState(state: any, title: string, url: string): void; abstract forward(): void; abstract back(): void; } export declare const LOCATION_INITIALIZED: InjectionToken<Promise<any>>; export interface LocationChangeEvent { type: string; state: any; } export interface LocationChangeListener { (event: LocationChangeEvent): any; }
export * from 'rxjs-compat/operator/findIndex';
export * from 'rxjs-compat/observable/ConnectableObservable';
export interface Schema { export?: boolean; flat?: boolean; lintFix?: boolean; module?: string; name: string; path?: string; prefix?: string; project?: string; selector?: string; skipImport?: boolean; spec?: boolean; }
import * as Lint from 'tslint'; import * as ts from 'typescript'; import { F2 } from './util/function'; import { NgWalker } from '.'; export declare class Rule extends Lint.Rules.AbstractRule { static readonly metadata: Lint.IRuleMetadata; static readonly FAILURE_STRING: string; static walkerBuilder: F2<ts.SourceFile, Lint.IOptions, NgWalker>; static validate(className: string, suffixList: string[]): boolean; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
interface SymbolConstructor { readonly prototype: Symbol; (description?: string | number): symbol; for(key: string): symbol; keyFor(sym: symbol): string | undefined; } declare var Symbol: SymbolConstructor;
import 'rxjs-compat/add/operator/repeatWhen';
import { Logger } from './logger'; export declare class IError extends Error { code?: number; stack?: string; } export declare class ProtractorError extends IError { static ERR_MSGS: string[]; static CODE: number; static SUPRESS_EXIT_CODE: boolean; message: string; constructor(logger: Logger, message: string, code: number, error?: Error); static log(logger: Logger, code: number, message: string, stack: string): void; } export declare class ConfigError extends ProtractorError { static CODE: number; constructor(logger: Logger, message: string, error?: Error); } export declare class BrowserError extends ProtractorError { static CODE: number; static ERR_MSGS: string[]; constructor(logger: Logger, message: string); } export declare class ErrorHandler { static isError(errMsgs: string[], e: Error): boolean; static parseError(e: Error): number; }
import { AsyncAction } from './AsyncAction'; import { AnimationFrameScheduler } from './AnimationFrameScheduler'; import { SchedulerAction } from '../types'; export class AnimationFrameAction<T> extends AsyncAction<T> { constructor(protected scheduler: AnimationFrameScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) { super(scheduler, work); } protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: any, delay: number = 0): any { if (delay !== null && delay > 0) { return super.requestAsyncId(scheduler, id, delay); } scheduler.actions.push(this); return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame( () => scheduler.flush(null))); } protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: any, delay: number = 0): any { if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) { return super.recycleAsyncId(scheduler, id, delay); } if (scheduler.actions.length === 0) { cancelAnimationFrame(id); scheduler.scheduled = undefined; } return undefined; } }
export * from 'rxjs-compat/operators/partition';
declare const _default: never[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import { ComponentFactory } from '../linker/component_factory'; import { NgModuleFactory } from '../linker/ng_module_factory'; import { Type } from '../type'; import { NgModuleDefinitionFactory, ProviderOverride } from './types'; export declare function overrideProvider(override: ProviderOverride): void; export declare function overrideComponentView(comp: Type<any>, componentFactory: ComponentFactory<any>): void; export declare function clearOverrides(): void; export declare function createNgModuleFactory(ngModuleType: Type<any>, bootstrapComponents: Type<any>[], defFactory: NgModuleDefinitionFactory): NgModuleFactory<any>;
import 'rxjs-compat/add/observable/pairs';
export * from 'rxjs-compat/operator/exhaustMap';
import { LanguageService, LanguageServiceHost } from './types'; export declare function createLanguageService(host: LanguageServiceHost): LanguageService;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'ESP': string[]; 'EUR': (string | undefined)[]; 'FKP': (string | undefined)[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NZD': (string | undefined)[]; 'RON': (string | undefined)[]; 'SSP': (string | undefined)[]; 'SYP': (string | undefined)[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'VEF': (string | undefined)[]; 'VND': (string | undefined)[]; 'XAF': never[]; 'XCD': (string | undefined)[]; 'XOF': never[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import { CompileDirectiveMetadata, CompileTemplateMetadata } from './compile_metadata'; import { CompilerConfig } from './config'; import { ViewEncapsulation } from './core'; import { HtmlParser } from './ml_parser/html_parser'; import { ResourceLoader } from './resource_loader'; import { UrlResolver } from './url_resolver'; import { SyncAsync } from './util'; export interface PrenormalizedTemplateMetadata { ngModuleType: any; componentType: any; moduleUrl: string; template: string | null; templateUrl: string | null; styles: string[]; styleUrls: string[]; interpolation: [string, string] | null; encapsulation: ViewEncapsulation | null; animations: any[]; preserveWhitespaces: boolean | null; } export declare class DirectiveNormalizer { private _resourceLoader; private _urlResolver; private _htmlParser; private _config; private _resourceLoaderCache; constructor(_resourceLoader: ResourceLoader, _urlResolver: UrlResolver, _htmlParser: HtmlParser, _config: CompilerConfig); clearCache(): void; clearCacheFor(normalizedDirective: CompileDirectiveMetadata): void; private _fetch; normalizeTemplate(prenormData: PrenormalizedTemplateMetadata): SyncAsync<CompileTemplateMetadata>; private _preParseTemplate; private _preparseLoadedTemplate; private _normalizeTemplateMetadata; private _normalizeLoadedTemplateMetadata; private _inlineStyles; private _loadMissingExternalStylesheets; private _normalizeStylesheet; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'SCR': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import 'rxjs-compat/add/operator/auditTime';
class SyncTestZoneSpec implements ZoneSpec { runZone = Zone.current; constructor(namePrefix: string) { this.name = 'syncTestZone for ' + namePrefix; } name: string; onScheduleTask(delegate: ZoneDelegate, current: Zone, target: Zone, task: Task): Task { switch (task.type) { case 'microTask': case 'macroTask': throw new Error(`Cannot call ${task.source} from within a sync test.`); case 'eventTask': task = delegate.scheduleTask(target, task); break; } return task; } } (Zone as any)['SyncTestZoneSpec'] = SyncTestZoneSpec;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'GEL': (string | undefined)[]; 'KZT': string[]; 'RON': (string | undefined)[]; 'RUB': string[]; 'RUR': string[]; 'THB': string[]; 'TMT': string[]; 'TWD': string[]; 'UAH': string[]; 'XXX': string[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/util/subscribeToObservable';
export interface Schema { help?: HelpUnion; } export declare type HelpUnion = boolean | HelpEnum; export declare enum HelpEnum { HelpJSON = "JSON", JSON = "json" }
declare const _default: never[]; export default _default;
export * from 'rxjs-compat/operators/first';
import { TemplateRef as ViewEngine_TemplateRef } from '../linker/template_ref'; import { TNode } from './interfaces/node'; import { LViewData } from './interfaces/view'; export declare function templateRefExtractor(tNode: TNode, currentView: LViewData): ViewEngine_TemplateRef<{}>;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import * as Lint from 'tslint'; import * as ts from 'typescript'; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; } export declare class ClassMetadataWalker extends Lint.RuleWalker { visitClassDeclaration(node: ts.ClassDeclaration): void; private validateInterfaces; private validateMethods; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'NZD': string[]; 'USD': string[]; } | undefined)[]; export default _default;
Zone.__load_patch('shadydom', (global: any, Zone: ZoneType, api: _ZonePrivate) => { const windowPrototype = Object.getPrototypeOf(window); if (windowPrototype && windowPrototype.hasOwnProperty('addEventListener')) { (windowPrototype as any)[Zone.__symbol__('addEventListener')] = null; (windowPrototype as any)[Zone.__symbol__('removeEventListener')] = null; api.patchEventTarget(global, [windowPrototype]); } if (Node.prototype.hasOwnProperty('addEventListener')) { (Node.prototype as any)[Zone.__symbol__('addEventListener')] = null; (Node.prototype as any)[Zone.__symbol__('removeEventListener')] = null; api.patchEventTarget(global, [Node.prototype]); } });
export declare class Headers { constructor(headers?: Headers | { [name: string]: any; } | null); static fromResponseHeaderString(headersString: string): Headers; append(name: string, value: string): void; delete(name: string): void; forEach(fn: (values: string[], name: string | undefined, headers: Map<string, string[]>) => void): void; get(name: string): string | null; has(name: string): boolean; keys(): string[]; set(name: string, value: string | string[]): void; values(): string[][]; toJSON(): { [name: string]: any; }; getAll(name: string): string[] | null; entries(): void; private mayBeSetNormalizedName; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'CNY': string[]; 'JPY': string[]; 'RON': (string | undefined)[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/operator/mergeAll';
import { ObservableInput } from '../types'; import { Subscription } from '../Subscription'; import { InnerSubscriber } from '../InnerSubscriber'; import { OuterSubscriber } from '../OuterSubscriber'; import { Subscriber } from '../Subscriber'; import { subscribeTo } from './subscribeTo'; export function subscribeToResult<T, R>( outerSubscriber: OuterSubscriber<T, R>, result: any, outerValue?: T, outerIndex?: number, destination?: Subscriber<any> ): Subscription; export function subscribeToResult<T, R>( outerSubscriber: OuterSubscriber<T, R>, result: any, outerValue?: T, outerIndex?: number, destination: Subscriber<any> = new InnerSubscriber(outerSubscriber, outerValue, outerIndex) ): Subscription | void { if (destination.closed) { return; } return subscribeTo(result)(destination); }
export * from 'rxjs-compat/operators/distinctUntilChanged';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AMD': string[]; 'JPY': string[]; 'THB': string[]; 'TWD': string[]; } | undefined)[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'CDF': string[]; 'JPY': string[]; 'KES': string[]; 'THB': string[]; 'TWD': string[]; 'TZS': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export {};
import { Binary, OS } from './binary'; export declare class Standalone extends Binary { static id: string; static isDefault: boolean; static os: OS[]; static versionDefault: string; constructor(opt_alternativeCdn?: string); id(): string; prefix(): string; suffix(): string; executableSuffix(): string; getVersionList(): Promise<string[]>; }
import 'rxjs-compat/add/operator/buffer';
import { Observable } from '../Observable'; import { SchedulerLike } from '../types'; import { Subscription } from '../Subscription'; import { subscribeToPromise } from '../util/subscribeToPromise'; export function fromPromise<T>(input: PromiseLike<T>, scheduler?: SchedulerLike) { if (!scheduler) { return new Observable<T>(subscribeToPromise(input)); } else { return new Observable<T>(subscriber => { const sub = new Subscription(); sub.add(scheduler.schedule(() => input.then( value => { sub.add(scheduler.schedule(() => { subscriber.next(value); sub.add(scheduler.schedule(() => subscriber.complete())); })); }, err => { sub.add(scheduler.schedule(() => subscriber.error(err))); } ))); return sub; }); } }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { Observable } from 'rxjs'; export declare class QueryList<T> { readonly dirty = true; private _results; readonly changes: Observable<any>; readonly length: number; readonly first: T; readonly last: T; map<U>(fn: (item: T, index: number, array: T[]) => U): U[]; filter(fn: (item: T, index: number, array: T[]) => boolean): T[]; find(fn: (item: T, index: number, array: T[]) => boolean): T | undefined; reduce<U>(fn: (prevValue: U, curValue: T, curIndex: number, array: T[]) => U, init: U): U; forEach(fn: (item: T, index: number, array: T[]) => void): void; some(fn: (value: T, index: number, array: T[]) => boolean): boolean; toArray(): T[]; toString(): string; reset(res: Array<T | any[]>): void; notifyOnChanges(): void; setDirty(): void; destroy(): void; }
import { Subscriber } from '../Subscriber'; import { iterator as Symbol_iterator } from '../symbol/iterator'; export const subscribeToIterable = <T>(iterable: Iterable<T>) => (subscriber: Subscriber<T>) => { const iterator = iterable[Symbol_iterator](); do { const item = iterator.next(); if (item.done) { subscriber.complete(); break; } subscriber.next(item.value); if (subscriber.closed) { break; } } while (true); if (typeof iterator.return === 'function') { subscriber.add(() => { if (iterator.return) { iterator.return(); } }); } return subscriber; };
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NOK': string[]; 'NZD': (string | undefined)[]; 'RON': (string | undefined)[]; 'TWD': (string | undefined)[]; 'USD': (string | undefined)[]; 'VND': (string | undefined)[]; 'XAF': never[]; 'XCD': (string | undefined)[]; 'XPF': never[]; } | undefined)[]; export default _default;
import { R3InjectorMetadata, R3NgModuleMetadata } from '@angular/compiler'; import * as ts from 'typescript'; import { Decorator, ReflectionHost } from '../../host'; import { AnalysisOutput, CompileResult, DecoratorHandler } from '../../transform'; import { SelectorScopeRegistry } from './selector_scope'; export interface NgModuleAnalysis { ngModuleDef: R3NgModuleMetadata; ngInjectorDef: R3InjectorMetadata; } export declare class NgModuleDecoratorHandler implements DecoratorHandler<NgModuleAnalysis, Decorator> { private checker; private reflector; private scopeRegistry; private isCore; constructor(checker: ts.TypeChecker, reflector: ReflectionHost, scopeRegistry: SelectorScopeRegistry, isCore: boolean); detect(node: ts.Declaration, decorators: Decorator[] | null): Decorator | undefined; analyze(node: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<NgModuleAnalysis>; compile(node: ts.ClassDeclaration, analysis: NgModuleAnalysis): CompileResult[]; private _extractModuleFromModuleWithProvidersFn; private resolveTypeList; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export * from './src/index';
export * from 'rxjs-compat/operator/throttle';
export * from 'rxjs-compat/operator/first';
import { IOptions, IRuleMetadata, RuleFailure, Rules } from 'tslint/lib'; import { SourceFile } from 'typescript/lib/typescript'; import { ComponentMetadata } from './angular/metadata'; import { NgWalker } from './angular/ngWalker'; export declare class Rule extends Rules.AbstractRule { static readonly metadata: IRuleMetadata; static readonly FAILURE_STRING: string; apply(sourceFile: SourceFile): RuleFailure[]; isEnabled(): boolean; } export declare type PropertyType = 'animations' | 'styles' | 'template'; export declare type PropertyPair = { [key in PropertyType]?: number; }; export declare const getAnimationsFailure: (value: number, limit?: number) => string; export declare const getStylesFailure: (value: number, limit?: number) => string; export declare const getTemplateFailure: (value: number, limit?: number) => string; export declare class MaxInlineDeclarationsWalker extends NgWalker { private readonly animationsLinesLimit; private readonly stylesLinesLimit; private readonly templateLinesLimit; private readonly newLineRegExp; constructor(sourceFile: SourceFile, options: IOptions); protected visitNgComponent(metadata: ComponentMetadata): void; private getLinesCount; private getInlineAnimationsLinesCount; private validateInlineAnimations; private getInlineStylesLinesCount; private validateInlineStyles; private getTemplateLinesCount; private hasInlineTemplate; private validateInlineTemplate; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'KES': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { OutputEmitter } from './abstract_emitter'; import * as o from './output_ast'; export declare class JavaScriptEmitter implements OutputEmitter { emitStatements(genFilePath: string, stmts: o.Statement[], preamble?: string): string; }
import 'rxjs-compat/add/operator/defaultIfEmpty';
import { DisplayProcessor } from "../display-processor"; import { CustomReporterResult } from "../spec-reporter"; export declare class DefaultProcessor extends DisplayProcessor { private static displaySpecDescription(spec); displayJasmineStarted(): string; displaySuite(suite: CustomReporterResult): string; displaySuccessfulSpec(spec: CustomReporterResult): string; displayFailedSpec(spec: CustomReporterResult): string; displaySpecErrorMessages(spec: CustomReporterResult): string; displaySummaryErrorMessages(spec: CustomReporterResult): string; displayPendingSpec(spec: CustomReporterResult): string; private displayErrorMessages(spec, withStacktrace); }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ESP': string[]; 'JPY': string[]; 'KMF': (string | undefined)[]; 'MXN': string[]; 'RUB': (string | undefined)[]; 'THB': string[]; 'TWD': string[]; } | undefined)[]; export default _default;
export * from './ivy_switch_on';
import { TemplateInfo } from './common'; import { Hover } from './types'; export declare function getHover(info: TemplateInfo): Hover | undefined;
import { Observable } from '../Observable'; import { Operator } from '../Operator'; import { Subscriber } from '../Subscriber'; import { EmptyError } from '../util/EmptyError'; import { Observer, MonoTypeOperatorFunction, TeardownLogic } from '../types'; export function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T> { return (source: Observable<T>) => source.lift(new SingleOperator(predicate, source)); } class SingleOperator<T> implements Operator<T, T> { constructor(private predicate?: (value: T, index: number, source: Observable<T>) => boolean, private source?: Observable<T>) { } call(subscriber: Subscriber<T>, source: any): TeardownLogic { return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source)); } } class SingleSubscriber<T> extends Subscriber<T> { private seenValue: boolean = false; private singleValue: T; private index: number = 0; constructor(destination: Observer<T>, private predicate?: (value: T, index: number, source: Observable<T>) => boolean, private source?: Observable<T>) { super(destination); } private applySingleValue(value: T): void { if (this.seenValue) { this.destination.error('Sequence contains more than one element'); } else { this.seenValue = true; this.singleValue = value; } } protected _next(value: T): void { const index = this.index++; if (this.predicate) { this.tryNext(value, index); } else { this.applySingleValue(value); } } private tryNext(value: T, index: number): void { try { if (this.predicate(value, index, this.source)) { this.applySingleValue(value); } } catch (err) { this.destination.error(err); } } protected _complete(): void { const destination = this.destination; if (this.index > 0) { destination.next(this.seenValue ? this.singleValue : undefined); destination.complete(); } else { destination.error(new EmptyError); } } }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': string[]; 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { ElementRef, OnDestroy, Renderer2, StaticProvider } from '@angular/core'; import { ControlValueAccessor } from './control_value_accessor'; export declare const SELECT_VALUE_ACCESSOR: StaticProvider; export declare class SelectControlValueAccessor implements ControlValueAccessor { private _renderer; private _elementRef; value: any; onChange: (_: any) => void; onTouched: () => void; compareWith: (o1: any, o2: any) => boolean; private _compareWith; constructor(_renderer: Renderer2, _elementRef: ElementRef); writeValue(value: any): void; registerOnChange(fn: (value: any) => any): void; registerOnTouched(fn: () => any): void; setDisabledState(isDisabled: boolean): void; } export declare class NgSelectOption implements OnDestroy { private _element; private _renderer; private _select; id: string; constructor(_element: ElementRef, _renderer: Renderer2, _select: SelectControlValueAccessor); ngValue: any; value: any; ngOnDestroy(): void; }
import { DoCheck, TemplateRef, ViewContainerRef } from '@angular/core'; export declare class SwitchView { private _viewContainerRef; private _templateRef; private _created; constructor(_viewContainerRef: ViewContainerRef, _templateRef: TemplateRef<Object>); create(): void; destroy(): void; enforceState(created: boolean): void; } export declare class NgSwitch { private _defaultViews; private _defaultUsed; private _caseCount; private _lastCaseCheckIndex; private _lastCasesMatched; private _ngSwitch; ngSwitch: any; private _updateDefaultCases; } export declare class NgSwitchCase implements DoCheck { private ngSwitch; private _view; ngSwitchCase: any; constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef<Object>, ngSwitch: NgSwitch); ngDoCheck(): void; } export declare class NgSwitchDefault { constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef<Object>, ngSwitch: NgSwitch); }
export * from 'rxjs-compat/operator/race';
export * from 'rxjs-compat/observable/DeferObservable';
import { KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory } from './keyvalue_differs'; export declare class DefaultKeyValueDifferFactory<K, V> implements KeyValueDifferFactory { constructor(); supports(obj: any): boolean; create<K, V>(): KeyValueDiffer<K, V>; } export declare class DefaultKeyValueDiffer<K, V> implements KeyValueDiffer<K, V>, KeyValueChanges<K, V> { private _records; private _mapHead; private _appendAfter; private _previousMapHead; private _changesHead; private _changesTail; private _additionsHead; private _additionsTail; private _removalsHead; private _removalsTail; readonly isDirty: boolean; forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void; forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void; forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void; forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void; forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void; diff(map?: Map<any, any> | { [k: string]: any; } | null): any; onDestroy(): void; check(map: Map<any, any> | { [k: string]: any; }): boolean; private _insertBeforeOrAppend; private _getOrCreateRecordForKey; private _maybeAddToChanges; private _addToAdditions; private _addToChanges; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ATS': string[]; } | undefined)[]; export default _default;
import { Observable } from '../Observable'; import { noop } from '../util/noop'; export const NEVER = new Observable<never>(noop); export function never () { return NEVER; }
export declare class LaunchEditorError extends Error { originalError: Error; constructor(originalError: Error); }
import 'rxjs-compat/add/operator/toPromise';
export * from './compiler';
import 'rxjs-compat/add/operator/distinctUntilChanged';
export * from 'rxjs-compat/operator/max';
export declare class HttpClientTestingModule { }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'UGX': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import { Operator } from '../Operator'; import { Subscriber } from '../Subscriber'; import { Observable } from '../Observable'; import { MonoTypeOperatorFunction, TeardownLogic } from '../types'; export function retry<T>(count: number = -1): MonoTypeOperatorFunction<T> { return (source: Observable<T>) => source.lift(new RetryOperator(count, source)); } class RetryOperator<T> implements Operator<T, T> { constructor(private count: number, private source: Observable<T>) { } call(subscriber: Subscriber<T>, source: any): TeardownLogic { return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source)); } } class RetrySubscriber<T> extends Subscriber<T> { constructor(destination: Subscriber<any>, private count: number, private source: Observable<T>) { super(destination); } error(err: any) { if (!this.isStopped) { const { source, count } = this; if (count === 0) { return super.error(err); } else if (count > -1) { this.count = count - 1; } source.subscribe(this._unsubscribeAndRecycle()); } } }
import { Observable } from '../Observable'; import { fromArray } from '../observable/fromArray'; import { scalar } from '../observable/scalar'; import { empty } from '../observable/empty'; import { concat as concatStatic } from '../observable/concat'; import { isScheduler } from '../util/isScheduler'; import { MonoTypeOperatorFunction, OperatorFunction, SchedulerLike } from '../types'; export function startWith<T>(scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>; export function startWith<T, D = T>(v1: D, scheduler?: SchedulerLike): OperatorFunction<T, T | D>; export function startWith<T, D = T, E = T>(v1: D, v2: E, scheduler?: SchedulerLike): OperatorFunction<T, T | D | E>; export function startWith<T, D = T, E = T, F = T>(v1: D, v2: E, v3: F, scheduler?: SchedulerLike): OperatorFunction<T, T | D | E | F>; export function startWith<T, D = T, E = T, F = T, G = T>(v1: D, v2: E, v3: F, v4: G, scheduler?: SchedulerLike): OperatorFunction<T, T | D | E | F | G>; export function startWith<T, D = T, E = T, F = T, G = T, H = T>(v1: D, v2: E, v3: F, v4: G, v5: H, scheduler?: SchedulerLike): OperatorFunction<T, T | D | E | F | G | H>; export function startWith<T, D = T, E = T, F = T, G = T, H = T, I = T>(v1: D, v2: E, v3: F, v4: G, v5: H, v6: I, scheduler?: SchedulerLike): OperatorFunction<T, T | D | E | F | G | H | I>; export function startWith<T, D = T>(...array: Array<D | SchedulerLike>): OperatorFunction<T, T | D>; export function startWith<T, D>(...array: Array<T | SchedulerLike>): OperatorFunction<T, T | D> { return (source: Observable<T>) => { let scheduler = <SchedulerLike>array[array.length - 1]; if (isScheduler(scheduler)) { array.pop(); } else { scheduler = null; } const len = array.length; if (len === 1 && !scheduler) { return concatStatic(scalar(array[0] as T), source); } else if (len > 0) { return concatStatic(fromArray(array as T[], scheduler), source); } else { return concatStatic<T>(empty(scheduler) as any, source); } }; }
export * from './metadata'; export * from './version'; export { TypeDecorator } from './util/decorators'; export * from './di'; export { createPlatform, assertPlatform, destroyPlatform, getPlatform, PlatformRef, ApplicationRef, createPlatformFactory, NgProbeToken } from './application_ref'; export { enableProdMode, isDevMode } from './is_dev_mode'; export { APP_ID, PACKAGE_ROOT_URL, PLATFORM_INITIALIZER, PLATFORM_ID, APP_BOOTSTRAP_LISTENER } from './application_tokens'; export { APP_INITIALIZER, ApplicationInitStatus } from './application_init'; export * from './zone'; export * from './render'; export * from './linker'; export { DebugElement, DebugNode, asNativeElements, getDebugNode, Predicate } from './debug/debug_node'; export { GetTestability, Testability, TestabilityRegistry, setTestabilityGetter } from './testability/testability'; export * from './change_detection'; export * from './platform_core_providers'; export { TRANSLATIONS, TRANSLATIONS_FORMAT, LOCALE_ID, MissingTranslationStrategy } from './i18n/tokens'; export { ApplicationModule } from './application_module'; export { wtfCreateScope, wtfLeave, wtfStartTimeRange, wtfEndTimeRange, WtfScopeFn } from './profile/profile'; export { Type } from './type'; export { EventEmitter } from './event_emitter'; export { ErrorHandler } from './error_handler'; export * from './core_private_export'; export * from './core_render3_private_export'; export { Sanitizer, SecurityContext } from './sanitization/security'; export * from './codegen_private_exports';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ANG': string[]; 'AUD': string[]; 'CAD': string[]; 'FJD': string[]; 'JPY': string[]; 'SBD': string[]; 'THB': string[]; 'TWD': string[]; 'USD': string[]; 'XPF': never[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import { Subscriber } from './Subscriber'; import { InnerSubscriber } from './InnerSubscriber'; export class OuterSubscriber<T, R> extends Subscriber<T> { notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void { this.destination.next(innerValue); } notifyError(error: any, innerSub: InnerSubscriber<T, R>): void { this.destination.error(error); } notifyComplete(innerSub: InnerSubscriber<T, R>): void { this.destination.complete(); } }
export * from 'rxjs-compat/operators/skipLast';
export declare const SelectorValidator: { attribute(selector: string): boolean; element(selector: string): boolean; kebabCase(selector: string): boolean; camelCase(selector: string): boolean; prefix(prefix: string, selectorType: string): Function; };
import 'rxjs-compat/add/operator/mergeAll';
import * as webdriver from 'selenium-webdriver'; import * as chrome from 'selenium-webdriver/chrome'; import * as firefox from 'selenium-webdriver/firefox'; import * as http from 'selenium-webdriver/http'; import * as remote from 'selenium-webdriver/remote'; import { ElementHelper, ProtractorBrowser } from './browser'; import { ElementArrayFinder, ElementFinder } from './element'; import { ProtractorExpectedConditions } from './expectedConditions'; import { ProtractorBy } from './locators'; export declare class Ptor { browser: ProtractorBrowser; $: (search: string) => ElementFinder; $$: (search: string) => ElementArrayFinder; element: ElementHelper; By: ProtractorBy; by: ProtractorBy; wrapDriver: (webdriver: webdriver.WebDriver, baseUrl?: string, rootElement?: string, untrackOutstandingTimeouts?: boolean) => ProtractorBrowser; ExpectedConditions: ProtractorExpectedConditions; ProtractorBrowser: any; ElementFinder: any; ElementArrayFinder: any; ProtractorBy: any; ProtractorExpectedConditions: any; ActionSequence: typeof webdriver.ActionSequence; Browser: webdriver.IBrowser; Builder: typeof webdriver.Builder; Button: webdriver.IButton; Capabilities: typeof webdriver.Capabilities; Capability: webdriver.ICapability; EventEmitter: typeof webdriver.EventEmitter; FileDetector: typeof webdriver.FileDetector; Key: webdriver.IKey; Session: typeof webdriver.Session; WebDriver: typeof webdriver.WebDriver; WebElement: typeof webdriver.WebElement; WebElementPromise: typeof webdriver.WebElementPromise; error: typeof webdriver.error; logging: typeof webdriver.logging; promise: typeof webdriver.promise; until: typeof webdriver.until; Command: any; CommandName: any; utils: { firefox: typeof firefox; http: typeof http; remote: typeof remote; chrome: typeof chrome; }; } export declare let protractor: Ptor;
export { CompilerImpl as ɵCompilerImpl } from './compiler_factory'; export { platformCoreDynamic as ɵplatformCoreDynamic } from './platform_core_dynamic'; export { INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS as ɵINTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS } from './platform_providers'; export { ResourceLoaderImpl as ɵResourceLoaderImpl } from './resource_loader/resource_loader_impl';
export * from 'rxjs-compat/operator/bufferTime';
export * from 'rxjs-compat/observable/timer';
import { PipeTransform } from '@angular/core'; export declare class DeprecatedDatePipe implements PipeTransform { private _locale; constructor(_locale: string); transform(value: any, pattern?: string): string | null; }
import { ConstantPool } from '@angular/compiler'; import * as ts from 'typescript'; import { Decorator, ReflectionHost } from '../../host'; import { TypeCheckContext } from '../../typecheck'; import { CompileResult, DecoratorHandler } from './api'; export declare class IvyCompilation { private handlers; private checker; private reflector; private coreImportsFrom; private sourceToFactorySymbols; private analysis; private typeCheckMap; private dtsMap; private _diagnostics; constructor(handlers: DecoratorHandler<any, any>[], checker: ts.TypeChecker, reflector: ReflectionHost, coreImportsFrom: ts.SourceFile | null, sourceToFactorySymbols: Map<string, Set<string>> | null); analyzeSync(sf: ts.SourceFile): void; analyzeAsync(sf: ts.SourceFile): Promise<void> | undefined; private analyze; typeCheck(context: TypeCheckContext): void; compileIvyFieldFor(node: ts.Declaration, constantPool: ConstantPool): CompileResult[] | undefined; ivyDecoratorFor(node: ts.Declaration): Decorator | undefined; transformedDtsFor(tsFileName: string, dtsOriginalSource: string): string; readonly diagnostics: ReadonlyArray<ts.Diagnostic>; private getDtsTransformer; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare module "reflect-metadata" { } declare namespace Reflect { function decorate(decorators: ClassDecorator[], target: Function): Function; function decorate(decorators: (PropertyDecorator | MethodDecorator)[], target: Object, targetKey: string | symbol, descriptor?: PropertyDescriptor): PropertyDescriptor; function metadata(metadataKey: any, metadataValue: any): { (target: Function): void; (target: Object, targetKey: string | symbol): void; }; function defineMetadata(metadataKey: any, metadataValue: any, target: Object): void; function defineMetadata(metadataKey: any, metadataValue: any, target: Object, targetKey: string | symbol): void; function hasMetadata(metadataKey: any, target: Object): boolean; function hasMetadata(metadataKey: any, target: Object, targetKey: string | symbol): boolean; function hasOwnMetadata(metadataKey: any, target: Object): boolean; function hasOwnMetadata(metadataKey: any, target: Object, targetKey: string | symbol): boolean; function getMetadata(metadataKey: any, target: Object): any; function getMetadata(metadataKey: any, target: Object, targetKey: string | symbol): any; function getOwnMetadata(metadataKey: any, target: Object): any; function getOwnMetadata(metadataKey: any, target: Object, targetKey: string | symbol): any; function getMetadataKeys(target: Object): any[]; function getMetadataKeys(target: Object, targetKey: string | symbol): any[]; function getOwnMetadataKeys(target: Object): any[]; function getOwnMetadataKeys(target: Object, targetKey: string | symbol): any[]; function deleteMetadata(metadataKey: any, target: Object): boolean; function deleteMetadata(metadataKey: any, target: Object, targetKey: string | symbol): boolean; }
import * as q from 'q'; import { Config } from '../config'; import { DriverProvider } from './driverProvider'; export declare class Hosted extends DriverProvider { constructor(config: Config); protected setupDriverEnv(): q.Promise<any>; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ATS': string[]; 'AUD': string[]; 'BGM': string[]; 'BGO': string[]; 'CUC': (string | undefined)[]; 'DEM': string[]; 'FKP': (string | undefined)[]; 'GNF': (string | undefined)[]; 'KMF': (string | undefined)[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SYP': never[]; 'THB': string[]; 'TWD': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
declare const _default: never[]; export default _default;
import { TNode } from './interfaces/node'; export declare function throwCyclicDependencyError(token: any): never; export declare function throwMultipleComponentError(tNode: TNode): never; export declare function throwErrorIfNoChangesMode(creationMode: boolean, checkNoChangesMode: boolean, oldValue: any, currValue: any): never | void;
export declare function pipe(index: number, pipeName: string): any; export declare function pipeBind1(index: number, slotOffset: number, v1: any): any; export declare function pipeBind2(index: number, slotOffset: number, v1: any, v2: any): any; export declare function pipeBind3(index: number, slotOffset: number, v1: any, v2: any, v3: any): any; export declare function pipeBind4(index: number, slotOffset: number, v1: any, v2: any, v3: any, v4: any): any; export declare function pipeBindV(index: number, slotOffset: number, values: any[]): any;
export * from 'rxjs-compat/operators/finalize';
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'TZS': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/util/isArrayLike';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CDF': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
Zone.__load_patch('socketio', (global: any, Zone: ZoneType, api: _ZonePrivate) => { (Zone as any)[Zone.__symbol__('socketio')] = function patchSocketIO(io: any) { api.patchEventTarget(global, [io.Socket.prototype], { useG: false, chkDup: false, rt: true, diff: (task: any, delegate: any) => { return task.callback === delegate; } }); io.Socket.prototype.on = io.Socket.prototype.addEventListener; io.Socket.prototype.off = io.Socket.prototype.removeListener = io.Socket.prototype.removeAllListeners = io.Socket.prototype.removeEventListener; }; });
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': string[]; 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare const _default: never[]; export default _default;
export declare function _sanitizeStyle(value: string): string; export interface StyleSanitizeFn { (prop: string): boolean; (prop: string, value: string): string; }
export * from 'rxjs-compat/operators/publishBehavior';
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export * from './async'; export * from './component_fixture'; export * from './fake_async'; export { TestBed, getTestBed, inject, InjectSetupWrapper, withModule } from './test_bed'; export * from './test_bed_common'; export * from './before_each'; export * from './metadata_override'; export { MetadataOverrider as ɵMetadataOverrider } from './metadata_overrider'; export * from './private_export_testing';
import { Arguments } from '../models/interface'; import { SchematicCommand } from '../models/schematic-command'; import { Schema as NewCommandSchema } from './new'; export declare class NewCommand extends SchematicCommand<NewCommandSchema> { readonly allowMissingWorkspace = true; schematicName: string; run(options: NewCommandSchema & Arguments): Promise<number | void>; private parseCollectionName; }
import { ZipOperator } from '../observable/zip'; import { Observable } from '../Observable'; import { OperatorFunction, ObservableInput } from '../types'; export function zipAll<T>(): OperatorFunction<ObservableInput<T>, T[]>; export function zipAll<T>(): OperatorFunction<any, T[]>; export function zipAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>; export function zipAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>; export function zipAll<T, R>(project?: (...values: Array<any>) => R): OperatorFunction<T, R> { return (source: Observable<T>) => source.lift(new ZipOperator(project)); }
import { Configuration } from "./configuration"; export declare class ConfigurationParser { static parse(conf?: Configuration): Configuration; private static isWindows; private static defaultConfiguration; private static merge(template, override); }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BAM': string[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'EUR': (string | undefined)[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NZD': (string | undefined)[]; 'TWD': (string | undefined)[]; 'USD': (string | undefined)[]; 'VND': (string | undefined)[]; 'XCD': (string | undefined)[]; 'XPF': never[]; } | undefined)[]; export default _default;
import { Rule } from '@angular-devkit/schematics'; import { Schema as UniversalOptions } from './schema'; export default function (options: UniversalOptions): Rule;
declare module 'fast-deep-equal' { const equal: (a: any, b: any) => boolean; export = equal; }
import { Observer, TeardownLogic } from './internal/types'; import { Observable } from './internal/Observable'; import './internal/observable/dom/MiscJSDoc'; export class ObservableDoc { static create<T>(onSubscription: <R>(observer: Observer<R>) => TeardownLogic): Observable<T> { return new Observable<T>(onSubscription); } } export class ObserverDoc<T> { closed: boolean = false; next(value: T): void { return void 0; } error(err: any): void { return void 0; } complete(): void { return void 0; } } export class SubscribableOrPromiseDoc<T> { } export class ObservableInputDoc<T> { } export class TeardownLogicDoc { }
export * from 'rxjs-compat/operator/take';
export declare const LOCALE_DATA: { [localeId: string]: any; }; export declare function registerLocaleData(data: any, localeId?: string | any, extraData?: any): void; export declare const enum LocaleDataIndex { LocaleId = 0, DayPeriodsFormat = 1, DayPeriodsStandalone = 2, DaysFormat = 3, DaysStandalone = 4, MonthsFormat = 5, MonthsStandalone = 6, Eras = 7, FirstDayOfWeek = 8, WeekendRange = 9, DateFormat = 10, TimeFormat = 11, DateTimeFormat = 12, NumberSymbols = 13, NumberFormats = 14, CurrencySymbol = 15, CurrencyName = 16, Currencies = 17, PluralCase = 18, ExtraData = 19 } export declare const enum ExtraLocaleDataIndex { ExtraDayPeriodFormats = 0, ExtraDayPeriodStandalone = 1, ExtraDayPeriodsRules = 2 } export declare const enum CurrencyIndex { Symbol = 0, SymbolNarrow = 1, NbOfDigits = 2 }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'EUR': (string | undefined)[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NZD': (string | undefined)[]; 'TWD': (string | undefined)[]; 'UAH': string[]; 'UAK': string[]; 'USD': (string | undefined)[]; 'VND': (string | undefined)[]; 'XCD': (string | undefined)[]; } | undefined)[]; export default _default;
import * as ts from 'typescript'; import { ErrorCode } from './code'; export declare class FatalDiagnosticError { readonly code: ErrorCode; readonly node: ts.Node; readonly message: string; constructor(code: ErrorCode, node: ts.Node, message: string); toDiagnostic(): ts.DiagnosticWithLocation; } export declare function isFatalDiagnosticError(err: any): err is FatalDiagnosticError;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'HTG': string[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'LRD': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { InteropObservable } from '../types'; import { observable as Symbol_observable } from '../symbol/observable'; export function isInteropObservable(input: any): input is InteropObservable<any> { return input && typeof input[Symbol_observable] === 'function'; }
import { Injector } from '../di/injector'; import { Type } from '../type'; import { ComponentFactoryResolver } from './component_factory_resolver'; export declare abstract class NgModuleRef<T> { abstract readonly injector: Injector; abstract readonly componentFactoryResolver: ComponentFactoryResolver; abstract readonly instance: T; abstract destroy(): void; abstract onDestroy(callback: () => void): void; } export interface InternalNgModuleRef<T> extends NgModuleRef<T> { _bootstrapComponents: Type<any>[]; } export declare abstract class NgModuleFactory<T> { abstract readonly moduleType: Type<T>; abstract create(parentInjector: Injector | null): NgModuleRef<T>; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': string[]; 'CNH': string[]; 'ETB': string[]; 'JPY': string[]; 'THB': string[]; 'TWD': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { Subject } from './Subject'; import { Subscriber } from './Subscriber'; import { Subscription } from './Subscription'; import { SubscriptionLike } from './types'; import { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError'; export class BehaviorSubject<T> extends Subject<T> { constructor(private _value: T) { super(); } get value(): T { return this.getValue(); } _subscribe(subscriber: Subscriber<T>): Subscription { const subscription = super._subscribe(subscriber); if (subscription && !(<SubscriptionLike>subscription).closed) { subscriber.next(this._value); } return subscription; } getValue(): T { if (this.hasError) { throw this.thrownError; } else if (this.closed) { throw new ObjectUnsubscribedError(); } else { return this._value; } } next(value: T): void { super.next(this._value = value); } }
import * as child_process from 'child_process'; export declare let spawn: (cmd: string, args: string[], stdio?: any, opts?: child_process.SpawnOptions) => child_process.ChildProcess; export declare let spawnSync: (cmd: string, args: string[], stdio?: any, opts?: child_process.SpawnSyncOptions) => child_process.SpawnSyncReturns<any>; export declare function request(method: string, port: string, path: string, timeout?: number, data?: any): Promise<string>; export declare function adb(sdkPath: string, port: number, command: string, timeout: number, args?: string[]): Promise<string>;
import 'rxjs-compat/add/operator/scan';
export * from './public_api';
import * as ts from 'typescript'; import * as Lint from 'tslint'; import * as ast from './cssAst'; import { SourceMappingVisitor } from '../sourceMappingVisitor'; import { ComponentMetadata, StyleMetadata } from '../metadata'; export interface CssAstVisitorCtrl { new (sourceFile: ts.SourceFile, options: Lint.IOptions, context: ComponentMetadata, style: StyleMetadata, templateStart: number): any; } export declare class BasicCssAstVisitor extends SourceMappingVisitor implements ast.CssAstVisitor { protected _originalOptions: Lint.IOptions; protected context: ComponentMetadata; protected templateStart: number; constructor(sourceFile: ts.SourceFile, _originalOptions: Lint.IOptions, context: ComponentMetadata, style: StyleMetadata, templateStart: number); visitCssValue(ast: ast.CssStyleValueAst, context?: any): any; visitCssInlineRule(ast: ast.CssInlineRuleAst, context?: any): any; visitCssAtRulePredicate(ast: ast.CssAtRulePredicateAst, context?: any): any; visitCssKeyframeRule(ast: ast.CssKeyframeRuleAst, context?: any): any; visitCssKeyframeDefinition(ast: ast.CssKeyframeDefinitionAst, context?: any): any; visitCssMediaQueryRule(ast: ast.CssMediaQueryRuleAst, context?: any): any; visitCssSelectorRule(ast: ast.CssSelectorRuleAst, context?: any): any; visitCssSelector(ast: ast.CssSelectorAst, context?: any): any; visitCssSimpleSelector(ast: ast.CssSimpleSelectorAst, context?: any): any; visitCssPseudoSelector(ast: ast.CssPseudoSelectorAst, context?: any): any; visitCssDefinition(ast: ast.CssDefinitionAst, context?: any): any; visitCssBlock(ast: ast.CssBlockAst, context?: any): any; visitCssStylesBlock(ast: ast.CssStylesBlockAst, context?: any): any; visitCssStyleSheet(ast: ast.CssStyleSheetAst, context?: any): any; visitCssUnknownRule(ast: ast.CssUnknownRuleAst, context?: any): any; visitCssUnknownTokenList(ast: ast.CssUnknownTokenListAst, context?: any): any; }
declare namespace Intl { type NumberFormatPartTypes = "currency" | "decimal" | "fraction" | "group" | "infinity" | "integer" | "literal" | "minusSign" | "nan" | "plusSign" | "percentSign"; interface NumberFormatPart { type: NumberFormatPartTypes; value: string; } interface NumberFormat { formatToParts(number?: number): NumberFormatPart[]; } }
export * from 'rxjs-compat/operator/merge';
export * from 'rxjs-compat/observable/forkJoin';
import { Version } from '@angular/core'; export declare const VERSION: Version;
import { Rule } from '@angular-devkit/schematics'; import { Schema as NgNewOptions } from './schema'; export default function (options: NgNewOptions): Rule;
export * from './src/forms';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'KES': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export declare function getTypeOf(instance: any ): any; export declare function instantiateType(type: Function, params?: any[]): any;
import { experimental, virtualFs } from '@angular-devkit/core'; import { Observable } from 'rxjs'; export declare class WorkspaceLoader { private _host; private _workspaceCacheMap; private _configFileNames; constructor(_host: virtualFs.Host); loadGlobalWorkspace(): Observable<experimental.workspace.Workspace | null>; loadWorkspace(projectPath?: string): Observable<experimental.workspace.Workspace | null>; private _getProjectWorkspaceFilePath; private _getGlobalWorkspaceFilePath; private _loadWorkspaceFromPath; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ANG': string[]; 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import 'rxjs-compat/add/observable/of';
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
const equal: (a: any, b: any) => boolean; export = equal;
export * from 'rxjs-compat/operators/pluck';
import 'rxjs-compat/add/operator/reduce';
import { Configuration } from "../configuration"; import { DisplayProcessor } from "../display-processor"; import { CustomReporterResult, ExecutedSpecs } from "../spec-reporter"; import { Logger } from "./logger"; import SuiteInfo = jasmine.SuiteInfo; export declare class ExecutionDisplay { private configuration; private logger; private specs; private static hasCustomDisplaySpecStarted(processors); private suiteHierarchy; private suiteHierarchyDisplayed; private hasCustomDisplaySpecStarted; constructor(configuration: Configuration, logger: Logger, specs: ExecutedSpecs, displayProcessors: DisplayProcessor[]); jasmineStarted(suiteInfo: SuiteInfo): void; specStarted(result: CustomReporterResult): void; successful(result: CustomReporterResult): void; failed(result: CustomReporterResult): void; pending(result: CustomReporterResult): void; suiteStarted(result: CustomReporterResult): void; suiteDone(result: CustomReporterResult): void; private ensureSuiteDisplayed(); private displaySuite(suite); private computeSuiteIndent(); }
import { EmitterVisitorContext, OutputEmitter } from './abstract_emitter'; import * as o from './output_ast'; export declare function debugOutputAstAsTypeScript(ast: o.Statement | o.Expression | o.Type | any[]): string; export declare type ReferenceFilter = (reference: o.ExternalReference) => boolean; export declare class TypeScriptEmitter implements OutputEmitter { emitStatementsAndContext(genFilePath: string, stmts: o.Statement[], preamble?: string, emitSourceMaps?: boolean, referenceFilter?: ReferenceFilter, importFilter?: ReferenceFilter): { sourceText: string; context: EmitterVisitorContext; }; emitStatements(genFilePath: string, stmts: o.Statement[], preamble?: string): string; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'ESP': string[]; 'EUR': (string | undefined)[]; 'FKP': (string | undefined)[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NZD': (string | undefined)[]; 'RON': (string | undefined)[]; 'SSP': (string | undefined)[]; 'SYP': (string | undefined)[]; 'TWD': (string | undefined)[]; 'USD': (string | undefined)[]; 'VEF': string[]; 'VND': (string | undefined)[]; 'XAF': never[]; 'XCD': (string | undefined)[]; 'XOF': never[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export interface Schema { configuration?: string; help?: HelpUnion; prod?: boolean; project?: string; } export declare type HelpUnion = boolean | HelpEnum; export declare enum HelpEnum { HelpJSON = "JSON", JSON = "json" }
import { Observable } from '../Observable'; import { MonoTypeOperatorFunction } from '../types'; export declare function repeatWhen<T>(notifier: (notifications: Observable<any>) => Observable<any>): MonoTypeOperatorFunction<T>;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'NGN': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import 'zone.js/dist/zone-testing'; import { getTestBed } from '@angular/core/testing'; import { BrowserDynamicTestingModule, platformBrowserDynamicTesting } from '@angular/platform-browser-dynamic/testing'; declare const require: any; getTestBed().initTestEnvironment( BrowserDynamicTestingModule, platformBrowserDynamicTesting() ); const context = require.context('./', true, /\.spec\.ts$/); context.keys().map(context);
import 'rxjs-compat/add/operator/partition';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': string[]; 'INR': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'NZD': (string | undefined)[]; 'TWD': (string | undefined)[]; 'USD': (string | undefined)[]; 'VND': (string | undefined)[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/util/toSubscriber';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': string[]; 'JPY': string[]; 'THB': string[]; 'TWD': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[] | undefined)[]; export default _default;
import 'rxjs-compat/add/observable/bindCallback';
export * from 'rxjs-compat/operators/throttle';
import { Observable } from '../Observable'; import { OperatorFunction } from '../types'; export declare function windowWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, Observable<T>>;
export * from './index'; export { COMMON_DIRECTIVES as ɵangular_packages_common_common_e } from './src/directives/index'; export { LocaleDataIndex as ɵangular_packages_common_common_c } from './src/i18n/locale_data'; export { findLocaleData as ɵangular_packages_common_common_d } from './src/i18n/locale_data_api'; export { DEPRECATED_PLURAL_FN as ɵangular_packages_common_common_a, getPluralCase as ɵangular_packages_common_common_b } from './src/i18n/localization'; export { COMMON_DEPRECATED_I18N_PIPES as ɵangular_packages_common_common_g } from './src/pipes/deprecated/index'; export { COMMON_PIPES as ɵangular_packages_common_common_f } from './src/pipes/index';
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'GBP': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NZD': (string | undefined)[]; 'TWD': (string | undefined)[]; 'XCD': (string | undefined)[]; } | undefined)[]; export default _default;
import { AsyncAction } from './AsyncAction'; import { AsyncScheduler } from './AsyncScheduler'; export class AnimationFrameScheduler extends AsyncScheduler { public flush(action?: AsyncAction<any>): void { this.active = true; this.scheduled = undefined; const {actions} = this; let error: any; let index: number = -1; let count: number = actions.length; action = action || actions.shift(); do { if (error = action.execute(action.state, action.delay)) { break; } } while (++index < count && (action = actions.shift())); this.active = false; if (error) { while (++index < count && (action = actions.shift())) { action.unsubscribe(); } throw error; } } }
export * from 'rxjs-compat/operators/refCount';
export * from 'rxjs-compat/operator/scan';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { Body } from './body'; import { ContentType, RequestMethod, ResponseContentType } from './enums'; import { Headers } from './headers'; import { RequestArgs } from './interfaces'; export declare class Request extends Body { method: RequestMethod; headers: Headers; url: string; private contentType; withCredentials: boolean; responseType: ResponseContentType; constructor(requestOptions: RequestArgs); detectContentType(): ContentType; detectContentTypeFromBody(): ContentType; getBody(): any; } export declare const ArrayBuffer: ArrayBufferConstructor;
import { CompileReflector, ExternalReference } from '@angular/compiler'; import { Component } from '@angular/core'; export declare const MODULE_SUFFIX = ""; export declare class JitReflector implements CompileReflector { tryAnnotations: any; private reflectionCapabilities; constructor(); guards(): {}; componentModuleUrl(type: any, cmpMetadata: Component): string; parameters(typeOrFunc: any): any[][]; annotations(typeOrFunc: any): any[]; shallowAnnotations(typeOrFunc: any): any[]; propMetadata(typeOrFunc: any): { [key: string]: any[]; }; hasLifecycleHook(type: any, lcProperty: string): boolean; resolveExternalReference(ref: ExternalReference): any; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'BRL': (string | undefined)[]; 'BYN': (string | undefined)[]; 'EGP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NOK': (string | undefined)[]; 'THB': string[]; 'TWD': (string | undefined)[]; 'USD': (string | undefined)[]; } | undefined)[]; export default _default;
declare const _default: never[]; export default _default;
import { StyleSanitizeFn } from '../../sanitization/style_sanitizer'; import { RElement } from '../interfaces/renderer'; import { PlayerContext } from './player'; export interface StylingContext extends Array<InitialStyles | { [key: string]: any; } | number | string | boolean | RElement | StyleSanitizeFn | PlayerContext | null> { [StylingIndex.PlayerContext]: PlayerContext | null; [StylingIndex.StyleSanitizerPosition]: StyleSanitizeFn | null; [StylingIndex.InitialStylesPosition]: InitialStyles; [StylingIndex.MasterFlagPosition]: number; [StylingIndex.ClassOffsetPosition]: number; [StylingIndex.ElementPosition]: RElement | null; [StylingIndex.PreviousMultiClassValue]: { [key: string]: any; } | string | null; [StylingIndex.PreviousMultiStyleValue]: { [key: string]: any; } | null; } export interface InitialStyles extends Array<string | null | boolean> { [0]: null; } export declare const enum StylingFlags { None = 0, Dirty = 1, Class = 2, Sanitize = 4, PlayerBuildersDirty = 8, BitCountSize = 4, BitMask = 15 } export declare const enum StylingIndex { PlayerContext = 0, StyleSanitizerPosition = 1, InitialStylesPosition = 2, MasterFlagPosition = 3, ClassOffsetPosition = 4, ElementPosition = 5, PreviousMultiClassValue = 6, PreviousMultiStyleValue = 7, SingleStylesStartPosition = 8, FlagsOffset = 0, PropertyOffset = 1, ValueOffset = 2, PlayerBuilderIndexOffset = 3, Size = 4, BitCountSize = 14, BitMask = 16383 }
export * from 'rxjs-compat/operators/last';
export * from 'rxjs-compat/operators/sampleTime';
export * from 'rxjs-compat/observable/BoundNodeCallbackObservable';
export * from './src/testing';
import { Summary, SummaryResolver } from '../summary_resolver'; import { StaticSymbol, StaticSymbolCache } from './static_symbol'; export interface AotSummaryResolverHost { loadSummary(filePath: string): string | null; isSourceFile(sourceFilePath: string): boolean; toSummaryFileName(fileName: string, referringSrcFileName: string): string; fromSummaryFileName(fileName: string, referringLibFileName: string): string; } export declare class AotSummaryResolver implements SummaryResolver<StaticSymbol> { private host; private staticSymbolCache; private summaryCache; private loadedFilePaths; private importAs; private knownFileNameToModuleNames; constructor(host: AotSummaryResolverHost, staticSymbolCache: StaticSymbolCache); isLibraryFile(filePath: string): boolean; toSummaryFileName(filePath: string, referringSrcFileName: string): string; fromSummaryFileName(fileName: string, referringLibFileName: string): string; resolveSummary(staticSymbol: StaticSymbol): Summary<StaticSymbol> | null; getSymbolsOf(filePath: string): StaticSymbol[] | null; getImportAs(staticSymbol: StaticSymbol): StaticSymbol; getKnownModuleName(importedFilePath: string): string | null; addSummary(summary: Summary<StaticSymbol>): void; private _loadSummaryFile; }
export * from 'rxjs-compat/operator/windowCount';
import { Observer, PartialObserver } from './types'; import { Subscription } from './Subscription'; export declare class Subscriber<T> extends Subscription implements Observer<T> { static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T>; syncErrorValue: any; syncErrorThrown: boolean; syncErrorThrowable: boolean; protected isStopped: boolean; protected destination: PartialObserver<any> | Subscriber<any>; private _parentSubscription; constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void), error?: (e?: any) => void, complete?: () => void); next(value?: T): void; error(err?: any): void; complete(): void; unsubscribe(): void; protected _next(value: T): void; protected _error(err: any): void; protected _complete(): void; _unsubscribeAndRecycle(): Subscriber<T>; } export declare class SafeSubscriber<T> extends Subscriber<T> { private _parentSubscriber; private _context; constructor(_parentSubscriber: Subscriber<T>, observerOrNext?: PartialObserver<T> | ((value: T) => void), error?: (e?: any) => void, complete?: () => void); next(value?: T): void; error(err?: any): void; complete(): void; private __tryOrUnsub; private __tryOrSetError; _unsubscribe(): void; }
import 'rxjs-compat/add/operator/windowTime';
import 'rxjs-compat/add/operator/find';
export * from './index';
import * as i18n from '../i18n_ast'; import { PlaceholderMapper, Serializer } from './serializer'; export declare class Xtb extends Serializer { write(messages: i18n.Message[], locale: string | null): string; load(content: string, url: string): { locale: string; i18nNodesByMsgId: { [msgId: string]: i18n.Node[]; }; }; digest(message: i18n.Message): string; createNameMapper(message: i18n.Message): PlaceholderMapper; }
export * from 'rxjs-compat/operator/sequenceEqual';
interface Ignore { add(pattern: string | Ignore): Ignore add(patterns: (string | Ignore)[]): Ignore filter(paths: string[]): string[] createFilter(): (path: string) => boolean ignores(pathname: string): boolean } declare function ignore(): Ignore export default ignore
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import * as ts from "typescript"; import { AbstractRule } from "./abstractRule"; import { ITypedRule, RuleFailure } from "./rule"; export declare abstract class TypedRule extends AbstractRule implements ITypedRule { apply(): RuleFailure[]; abstract applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[]; }
import { ɵStyleData } from '@angular/animations'; import { TriggerAst } from './animation_ast'; import { AnimationStateStyles, AnimationTransitionFactory } from './animation_transition_factory'; export declare function buildTrigger(name: string, ast: TriggerAst): AnimationTrigger; export declare class AnimationTrigger { name: string; ast: TriggerAst; transitionFactories: AnimationTransitionFactory[]; fallbackTransition: AnimationTransitionFactory; states: { [stateName: string]: AnimationStateStyles; }; constructor(name: string, ast: TriggerAst); readonly containsQueries: boolean; matchTransition(currentState: any, nextState: any, element: any, params: { [key: string]: any; }): AnimationTransitionFactory | null; matchStyles(currentState: any, params: { [key: string]: any; }, errors: any[]): ɵStyleData; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.TypedRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): Lint.RuleFailure[]; }
import { CompileShallowModuleMetadata } from '../compile_metadata'; import { InjectableCompiler } from '../injectable_compiler'; import * as o from '../output/output_ast'; import { OutputContext } from '../util'; import { R3DependencyMetadata } from './r3_factory'; import { R3Reference } from './util'; export interface R3NgModuleDef { expression: o.Expression; type: o.Type; additionalStatements: o.Statement[]; } export interface R3NgModuleMetadata { type: o.Expression; bootstrap: R3Reference[]; declarations: R3Reference[]; imports: R3Reference[]; exports: R3Reference[]; emitInline: boolean; } export declare function compileNgModule(meta: R3NgModuleMetadata): R3NgModuleDef; export interface R3InjectorDef { expression: o.Expression; type: o.Type; statements: o.Statement[]; } export interface R3InjectorMetadata { name: string; type: o.Expression; deps: R3DependencyMetadata[] | null; providers: o.Expression; imports: o.Expression; } export declare function compileInjector(meta: R3InjectorMetadata): R3InjectorDef; export declare function compileNgModuleFromRender2(ctx: OutputContext, ngModule: CompileShallowModuleMetadata, injectableCompiler: InjectableCompiler): void;
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.TypedRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): Lint.RuleFailure[]; }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare const _default: (string[] | undefined)[][]; export default _default;
import { Version } from '@angular/core'; export declare const VERSION: Version;
declare const _default: (string | string[])[][]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export * from './src/animations';
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.TypedRule { static metadata: Lint.IRuleMetadata; static INVALID_TYPES_ERROR: string; static SUGGEST_TEMPLATE_LITERALS: string; applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): Lint.RuleFailure[]; }
import { TransformJavascriptOutput } from '../helpers/transform-javascript'; export interface BuildOptimizerOptions { content?: string; originalFilePath?: string; inputFilePath?: string; outputFilePath?: string; emitSourceMap?: boolean; strict?: boolean; isSideEffectFree?: boolean; } export declare function buildOptimizer(options: BuildOptimizerOptions): TransformJavascriptOutput;
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; static FAILURE_STRING_NO_PREFIX: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.TypedRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; static FAILURE_FOR_AWAIT_OF: string; applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): Lint.RuleFailure[]; }
export { createCompilerHost } from './compiler_host'; export { createProgram } from './program';
import { virtualFs } from '@angular-devkit/core'; export declare class FileSystemHost extends virtualFs.ScopedHost<{}> { constructor(dir: string); }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.TypedRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): Lint.RuleFailure[]; }
#!/usr/bin/env node export {};
import { AbstractFormatter } from "../language/formatter/abstractFormatter"; import { IFormatterMetadata } from "../language/formatter/formatter"; import { RuleFailure } from "../language/rule/rule"; export declare class Formatter extends AbstractFormatter { static metadata: IFormatterMetadata; format(failures: RuleFailure[]): string; private mapToMessages; private pad; private getPositionMaxSize; private getRuleMaxSize; }
import { BaseException } from '@angular-devkit/core'; export declare class SchematicsException extends BaseException { } export declare class FileDoesNotExistException extends BaseException { constructor(path: string); } export declare class FileAlreadyExistException extends BaseException { constructor(path: string); } export declare class ContentHasMutatedException extends BaseException { constructor(path: string); } export declare class InvalidUpdateRecordException extends BaseException { constructor(); } export declare class MergeConflictException extends BaseException { constructor(path: string); } export declare class UnsuccessfulWorkflowExecution extends BaseException { constructor(); } export declare class UnimplementedException extends BaseException { constructor(); }
import { TaskExecutor } from '../../src'; import { RunSchematicTaskOptions } from './options'; export default function (): TaskExecutor<RunSchematicTaskOptions<{}>>;
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import { IOptions, IRule, RuleConstructor } from "./language/rule/rule"; export declare function loadRules(ruleOptionsList: IOptions[], rulesDirectories?: string | string[], isJs?: boolean): IRule[]; export declare function findRule(name: string, rulesDirectories?: string | string[]): RuleConstructor | undefined;
import { GeneratedFile } from '@angular/compiler'; import * as ts from 'typescript'; import * as api from '../transformers/api'; export declare class TscPassThroughProgram implements api.Program { private options; private host; private tsProgram; constructor(rootNames: ReadonlyArray<string>, options: api.CompilerOptions, host: api.CompilerHost, oldProgram?: api.Program); getTsProgram(): ts.Program; getTsOptionDiagnostics(cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<ts.Diagnostic>; getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<api.Diagnostic>; getTsSyntacticDiagnostics(sourceFile?: ts.SourceFile | undefined, cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<ts.Diagnostic>; getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<api.Diagnostic>; getTsSemanticDiagnostics(sourceFile?: ts.SourceFile | undefined, cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<ts.Diagnostic>; getNgSemanticDiagnostics(fileName?: string | undefined, cancellationToken?: ts.CancellationToken | undefined): ReadonlyArray<api.Diagnostic>; loadNgStructureAsync(): Promise<void>; listLazyRoutes(entryRoute?: string | undefined): api.LazyRoute[]; getLibrarySummaries(): Map<string, api.LibrarySummary>; getEmittedGeneratedFiles(): Map<string, GeneratedFile>; getEmittedSourceFiles(): Map<string, ts.SourceFile>; emit(opts?: { emitFlags?: api.EmitFlags; cancellationToken?: ts.CancellationToken; customTransformers?: api.CustomTransformers; emitCallback?: api.TsEmitCallback; mergeEmitResultsCallback?: api.TsMergeEmitResultsCallback; }): ts.EmitResult; }
import { RawSourceMap } from 'source-map'; import * as ts from 'typescript'; export interface TransformJavascriptOptions { content: string; inputFilePath?: string; outputFilePath?: string; emitSourceMap?: boolean; strict?: boolean; typeCheck?: boolean; getTransforms: Array<(program?: ts.Program) => ts.TransformerFactory<ts.SourceFile>>; } export interface TransformJavascriptOutput { content: string | null; sourceMap: RawSourceMap | null; emitSkipped: boolean; } export declare function transformJavascript(options: TransformJavascriptOptions): TransformJavascriptOutput;
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
declare const _default: never[]; export default _default;
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.TypedRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING_VALUE_RETURN: string; static FAILURE_STRING_VOID_RETURN: string; applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): Lint.RuleFailure[]; }
import { TagContentType, TagDefinition } from './tags'; export declare class XmlTagDefinition implements TagDefinition { closedByParent: boolean; requiredParents: { [key: string]: boolean; }; parentToAdd: string; implicitNamespacePrefix: string; contentType: TagContentType; isVoid: boolean; ignoreFirstLf: boolean; canSelfClose: boolean; requireExtraParent(currentParent: string): boolean; isClosedByChild(name: string): boolean; } export declare function getXmlTagDefinition(tagName: string): XmlTagDefinition;
declare const _default: never[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export declare function createTitle(): Title; export declare class Title { private _doc; constructor(_doc: any); getTitle(): string; setTitle(newTitle: string): void; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import * as o from '../output/output_ast'; import { OutputContext } from '../util'; export declare function mapToMapExpression(map: { [key: string]: o.Expression; }): o.LiteralMapExpr; export declare function convertMetaToOutput(meta: any, ctx: OutputContext): o.Expression; export declare function typeWithParameters(type: o.Expression, numParams: number): o.ExpressionType; export interface R3Reference { value: o.Expression; type: o.Expression; }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import { AnimationPlayer } from '@angular/animations'; export declare const enum AnimatorControlState { INITIALIZED = 1, STARTED = 2, FINISHED = 3, DESTROYED = 4 } export declare class CssKeyframesPlayer implements AnimationPlayer { readonly element: any; readonly keyframes: { [key: string]: string | number; }[]; readonly animationName: string; private readonly _duration; private readonly _delay; private readonly _finalStyles; private _onDoneFns; private _onStartFns; private _onDestroyFns; private _started; private _styler; parentPlayer: AnimationPlayer; readonly totalTime: number; readonly easing: string; currentSnapshot: { [key: string]: string; }; private _state; constructor(element: any, keyframes: { [key: string]: string | number; }[], animationName: string, _duration: number, _delay: number, easing: string, _finalStyles: { [key: string]: any; }); onStart(fn: () => void): void; onDone(fn: () => void): void; onDestroy(fn: () => void): void; destroy(): void; private _flushDoneFns; private _flushStartFns; finish(): void; setPosition(value: number): void; getPosition(): number; hasStarted(): boolean; init(): void; play(): void; pause(): void; restart(): void; reset(): void; private _buildStyler; beforeDestroy(): void; }
import * as ts from "typescript"; import { IOptions } from "../rule/rule"; import { ScopeAwareRuleWalker } from "./scopeAwareRuleWalker"; export declare abstract class BlockScopeAwareRuleWalker<T, U> extends ScopeAwareRuleWalker<T> { private readonly blockScopeStack; constructor(sourceFile: ts.SourceFile, options: IOptions); abstract createBlockScope(node: ts.Node): U; getAllBlockScopes(): U[]; getCurrentBlockScope(): U; getCurrentBlockDepth(): number; onBlockScopeStart(): void; onBlockScopeEnd(): void; findBlockScope(predicate: (scope: U) => boolean): U | undefined; protected visitNode(node: ts.Node): void; private isBlockScopeBoundary; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
export declare class EmptyOutletComponent { }
import { Type } from '@angular/core'; import { MonoTypeOperatorFunction } from 'rxjs'; import { Route } from '../config'; import { NavigationTransition } from '../router'; import { UrlTree } from '../url_tree'; export declare function recognize(rootComponentType: Type<any> | null, config: Route[], serializer: (url: UrlTree) => string, paramsInheritanceStrategy: 'emptyOnly' | 'always', relativeLinkResolution: 'legacy' | 'corrected'): MonoTypeOperatorFunction<NavigationTransition>;
import { HtmlParser } from '../ml_parser/html_parser'; import { InterpolationConfig } from '../ml_parser/interpolation_config'; import { ParseError } from '../parse_util'; import * as i18n from './i18n_ast'; import { Serializer } from './serializers/serializer'; export declare class MessageBundle { private _htmlParser; private _implicitTags; private _implicitAttrs; private _locale; private _messages; constructor(_htmlParser: HtmlParser, _implicitTags: string[], _implicitAttrs: { [k: string]: string[]; }, _locale?: string | null); updateFromTemplate(html: string, url: string, interpolationConfig: InterpolationConfig): ParseError[]; getMessages(): i18n.Message[]; write(serializer: Serializer, filterSources?: (path: string) => string): string; }
export * from 'rxjs-compat/operator/repeatWhen';
import 'rxjs-compat/add/operator/shareReplay';
import 'rxjs-compat/add/operator/race';
import * as core from '@angular/core'; export declare function inspectNativeElement(element: any): core.DebugNode | null; export declare function _createNgProbe(coreTokens: core.NgProbeToken[]): any; export declare const ELEMENT_PROBE_PROVIDERS: core.Provider[];
export { MockAnimationDriver, MockAnimationPlayer } from './mock_animation_driver';
import { Observable } from '../Observable'; import { SchedulerLike } from '../types'; export declare function fromIterable<T>(input: Iterable<T>, scheduler: SchedulerLike): Observable<T>;
export * from 'rxjs-compat/operator/audit';
export * from 'rxjs-compat/observable/ForkJoinObservable';
export { BrowserAnimationsModule, NoopAnimationsModule } from './module'; export { ANIMATION_MODULE_TYPE } from './providers'; export * from './private_export';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'PHP': string[]; 'THB': string[]; 'TWD': string[]; } | undefined)[]; export default _default;
import { IRuleMetadata } from 'tslint/lib'; import { SelectorRule } from './selectorNameBase'; export declare class Rule extends SelectorRule { static readonly metadata: IRuleMetadata; handleType: string; getPrefixFailure(prefixes: string[]): string; getStyleFailure(): string; getTypeFailure(): string; isEnabled(): boolean; }
export * from 'rxjs-compat/operators/merge';
export * from 'rxjs-compat/operators/windowCount';
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export * from 'rxjs-compat/util/EmptyError';
import { Subscriber } from '../Subscriber'; import { observable as Symbol_observable } from '../symbol/observable'; export const subscribeToObservable = <T>(obj: any) => (subscriber: Subscriber<T>) => { const obs = obj[Symbol_observable](); if (typeof obs.subscribe !== 'function') { throw new TypeError('Provided object does not correctly implement Symbol.observable'); } else { return obs.subscribe(subscriber); } };
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'BOB': string[]; 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { OperatorFunction, ObservableInput } from '../types'; export declare function zipAll<T>(): OperatorFunction<ObservableInput<T>, T[]>; export declare function zipAll<T>(): OperatorFunction<any, T[]>; export declare function zipAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>; export declare function zipAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;
import { Observable } from 'rxjs'; import { ReadyState } from '../enums'; import { Connection, ConnectionBackend } from '../interfaces'; import { Request } from '../static_request'; import { Response } from '../static_response'; export declare class JSONPConnection implements Connection { private _dom; private baseResponseOptions?; private _id; private _script; private _responseData; private _finished; readyState: ReadyState; request: Request; response: Observable<Response>; finished(data?: any): void; } export declare class JSONPBackend extends ConnectionBackend { private _browserJSONP; private _baseResponseOptions; createConnection(request: Request): JSONPConnection; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/operator/combineAll';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'NZD': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import 'rxjs-compat/add/operator/mergeScan';
declare function setPrototypeOf(o: any, proto: object | null): any; export = setPrototypeOf;
export { ajax } from '../internal/observable/dom/ajax'; export { AjaxRequest, AjaxResponse, AjaxError, AjaxTimeoutError } from '../internal/observable/dom/AjaxObservable';
import 'rxjs-compat/add/observable/generate';
import { Type } from '../type'; import { PlatformReflectionCapabilities } from './platform_reflection_capabilities'; import { GetterFn, MethodFn, SetterFn } from './types'; export declare const DELEGATE_CTOR: RegExp; export declare const INHERITED_CLASS: RegExp; export declare const INHERITED_CLASS_WITH_CTOR: RegExp; export declare class ReflectionCapabilities implements PlatformReflectionCapabilities { private _reflect; constructor(reflect?: any); isReflectionEnabled(): boolean; factory<T>(t: Type<T>): (args: any[]) => T; private _ownParameters; parameters(type: Type<any>): any[][]; private _ownAnnotations; annotations(typeOrFunc: Type<any>): any[]; private _ownPropMetadata; propMetadata(typeOrFunc: any): { [key: string]: any[]; }; hasLifecycleHook(type: any, lcProperty: string): boolean; guards(type: any): { [key: string]: any; }; getter(name: string): GetterFn; setter(name: string): SetterFn; method(name: string): MethodFn; importUri(type: any): string; resourceUri(type: any): string; resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any; resolveEnum(enumIdentifier: any, name: string): any; }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SCR': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/util/ArgumentOutOfRangeError';
import { MonoTypeOperatorFunction } from '../types'; export declare function max<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T>;
export * from 'rxjs-compat/Scheduler';
export interface Schema { collection?: string; defaults?: boolean; dryRun?: boolean; force?: boolean; help?: HelpUnion; interactive?: boolean; } export declare type HelpUnion = boolean | HelpEnum; export declare enum HelpEnum { HelpJSON = "JSON", JSON = "json" }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/scheduler/asap';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'PGK': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { NgAnalyzedModules } from '@angular/compiler'; import { AstResult } from './common'; import { Declarations, Diagnostics, TemplateSource } from './types'; export interface AstProvider { getTemplateAst(template: TemplateSource, fileName: string): AstResult; } export declare function getTemplateDiagnostics(fileName: string, astProvider: AstProvider, templates: TemplateSource[]): Diagnostics; export declare function getDeclarationDiagnostics(declarations: Declarations, modules: NgAnalyzedModules): Diagnostics;
export * from './ivy_switch_on';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'GEL': string[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'NZD': (string | undefined)[]; 'TWD': string[]; 'USD': string[]; 'VND': (string | undefined)[]; } | undefined)[]; export default _default;
import { AotCompilerOptions } from '../aot/compiler_options'; import { StaticReflector } from '../aot/static_reflector'; import { StaticSymbol } from '../aot/static_symbol'; import { CompileDirectiveMetadata, CompilePipeSummary } from '../compile_metadata'; import * as o from '../output/output_ast'; import { TemplateAst } from '../template_parser/template_ast'; import { OutputContext } from '../util'; export declare class TypeCheckCompiler { private options; private reflector; constructor(options: AotCompilerOptions, reflector: StaticReflector); compileComponent(componentId: string, component: CompileDirectiveMetadata, template: TemplateAst[], usedPipes: CompilePipeSummary[], externalReferenceVars: Map<StaticSymbol, string>, ctx: OutputContext): o.Statement[]; }
import { Configuration } from "../configuration"; export declare class ColorsDisplay { static init(configuration: Configuration): void; }
import 'rxjs-compat/add/operator/combineLatest';
export * from 'rxjs-compat/operators/tap';
import * as Lint from 'tslint'; import * as ts from 'typescript'; import { NgWalker } from './angular/ngWalker'; export declare class Rule extends Lint.Rules.AbstractRule { static readonly metadata: Lint.IRuleMetadata; static readonly FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; } export declare type LifecycleHooksMethods = 'ngAfterContentChecked' | 'ngAfterContentInit' | 'ngAfterViewChecked' | 'ngAfterViewInit' | 'ngDoCheck' | 'ngOnChanges' | 'ngOnDestroy' | 'ngOnInit'; export declare const lifecycleHooksMethods: Set<LifecycleHooksMethods>; export declare class ExpressionCallMetadataWalker extends NgWalker { visitCallExpression(node: ts.CallExpression): void; private validateCallExpression; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import { Rule } from '@angular-devkit/schematics'; import { Schema as ServiceOptions } from './schema'; export default function (options: ServiceOptions): Rule;
export * from './src/common'; export { registerLocaleData as ɵregisterLocaleData } from './src/i18n/locale_data';
export * from 'rxjs-compat/observable/defer';
export * from 'rxjs-compat/operator/skip';
import { concat as concatStatic } from '../observable/concat'; import { Observable } from '../Observable'; import { ObservableInput, OperatorFunction, MonoTypeOperatorFunction, SchedulerLike } from '../types'; export function concat<T>(scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>; export function concat<T, T2>(v2: ObservableInput<T2>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2>; export function concat<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3>; export function concat<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4>; export function concat<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5>; export function concat<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>; export function concat<T>(...observables: Array<ObservableInput<T> | SchedulerLike>): MonoTypeOperatorFunction<T>; export function concat<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike>): OperatorFunction<T, R>; export function concat<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike>): OperatorFunction<T, R> { return (source: Observable<T>) => source.lift.call(concatStatic<T, R>(source, ...observables)); }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'KES': string[]; 'THB': string[]; 'TWD': string[]; 'TZS': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { ElementRef, Injector, OnDestroy, OnInit, Renderer2 } from '@angular/core'; import { ControlValueAccessor } from './control_value_accessor'; import { NgControl } from './ng_control'; export declare const RADIO_VALUE_ACCESSOR: any; export declare class RadioControlRegistry { private _accessors; add(control: NgControl, accessor: RadioControlValueAccessor): void; remove(accessor: RadioControlValueAccessor): void; select(accessor: RadioControlValueAccessor): void; private _isSameGroup; } export declare class RadioControlValueAccessor implements ControlValueAccessor, OnDestroy, OnInit { private _renderer; private _elementRef; private _registry; private _injector; onChange: () => void; onTouched: () => void; name: string; formControlName: string; value: any; constructor(_renderer: Renderer2, _elementRef: ElementRef, _registry: RadioControlRegistry, _injector: Injector); ngOnInit(): void; ngOnDestroy(): void; writeValue(value: any): void; registerOnChange(fn: (_: any) => {}): void; fireUncheck(value: any): void; registerOnTouched(fn: () => {}): void; setDisabledState(isDisabled: boolean): void; private _checkName; private _throwNameError; }
import { Observable } from '../Observable'; import { defer } from './defer'; import { EMPTY } from './empty'; import { SubscribableOrPromise } from '../types'; export function iif<T, F>( condition: () => boolean, trueResult: SubscribableOrPromise<T> = EMPTY, falseResult: SubscribableOrPromise<F> = EMPTY ): Observable<T|F> { return defer<T|F>(() => condition() ? trueResult : falseResult); }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'MNT': string[]; 'SEK': (string | undefined)[]; 'THB': string[]; 'TWD': string[]; } | undefined)[]; export default _default;
export { RenderComponentType, Renderer, Renderer2, RendererFactory2, RendererStyleFlags2, RendererType2, RootRenderer } from './render/api';
import { CodeWithSourceMap } from './metadata'; export interface StyleTransformer { (style: string, url?: string): CodeWithSourceMap; } export interface TemplateTransformer { (template: string, url?: string): CodeWithSourceMap; } export interface UrlResolver { (url: string | null): string | null; } export declare const LogLevel: { Debug: number; Error: number; Info: number; None: number; }; export interface Config { interpolation: [string, string]; logLevel: number; predefinedDirectives: DirectiveDeclaration[]; resolveUrl: UrlResolver; transformStyle: StyleTransformer; transformTemplate: TemplateTransformer; } export interface DirectiveDeclaration { exportAs?: string; hostAttributes?: string[]; hostListeners?: string[]; hostProperties?: string[]; inputs?: string[]; outputs?: string[]; selector: string; } export declare const Config: Config;
export {};
import 'rxjs-compat/add/operator/take';
import { BinaryUrl } from './binary'; import { XmlConfigSource } from './config_source'; export declare class StandaloneXml extends XmlConfigSource { constructor(); getUrl(version: string): Promise<BinaryUrl>; getVersionList(): Promise<string[]>; private getLatestStandaloneVersion(); private getSpecificStandaloneVersion(inputVersion); }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export * from './src/testing';
export * from 'rxjs-compat/operator/windowCount';
export * from 'rxjs-compat/operator/concatMap';
export interface Config { help?: boolean; fork?: boolean; highlightDelay?: string; seleniumAddress?: string; logDir?: string; port?: number; } export declare function processArgs(argv: string[]): Config; export declare function printHelp(): void;
import { async, ComponentFixture, TestBed } from '@angular/core/testing'; import { <%= classify(name) %>Component } from './<%= dasherize(name) %>.component'; describe('<%= classify(name) %>Component', () => { let component: <%= classify(name) %>Component; let fixture: ComponentFixture<<%= classify(name) %>Component>; beforeEach(async(() => { TestBed.configureTestingModule({ declarations: [ <%= classify(name) %>Component ] }) .compileComponents(); })); beforeEach(() => { fixture = TestBed.createComponent(<%= classify(name) %>Component); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeTruthy(); }); });
export function not(pred: Function, thisArg: any): Function { function notPred(): any { return !((<any> notPred).pred.apply((<any> notPred).thisArg, arguments)); } (<any> notPred).pred = pred; (<any> notPred).thisArg = thisArg; return notPred; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BRL': (string | undefined)[]; 'BYN': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'ESP': string[]; 'EUR': (string | undefined)[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': string[]; 'NZD': (string | undefined)[]; 'TWD': (string | undefined)[]; 'USD': (string | undefined)[]; 'VEF': (string | undefined)[]; 'VND': (string | undefined)[]; 'XAF': never[]; 'XCD': (string | undefined)[]; 'XOF': never[]; } | undefined)[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BDT': never[]; 'BRL': (string | undefined)[]; 'BYN': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': never[]; 'INR': never[]; 'JPY': (string | undefined)[]; 'KHR': never[]; 'KRW': (string | undefined)[]; 'LAK': never[]; 'MNT': never[]; 'MXN': (string | undefined)[]; 'NZD': (string | undefined)[]; 'PLN': (string | undefined)[]; 'PYG': (string | undefined)[]; 'RUB': (string | undefined)[]; 'TWD': (string | undefined)[]; 'USD': (string | undefined)[]; 'VND': never[]; 'XAF': never[]; 'XCD': (string | undefined)[]; 'XOF': never[]; 'XPF': never[]; } | undefined)[]; export default _default;
import { R3PipeMetadata } from '@angular/compiler'; import * as ts from 'typescript'; import { Decorator, ReflectionHost } from '../../host'; import { AnalysisOutput, CompileResult, DecoratorHandler } from '../../transform'; import { SelectorScopeRegistry } from './selector_scope'; export declare class PipeDecoratorHandler implements DecoratorHandler<R3PipeMetadata, Decorator> { private checker; private reflector; private scopeRegistry; private isCore; constructor(checker: ts.TypeChecker, reflector: ReflectionHost, scopeRegistry: SelectorScopeRegistry, isCore: boolean); detect(node: ts.Declaration, decorators: Decorator[] | null): Decorator | undefined; analyze(clazz: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<R3PipeMetadata>; compile(node: ts.ClassDeclaration, analysis: R3PipeMetadata): CompileResult; }
import { Operator } from '../Operator'; import { Observable } from '../Observable'; import { Subscriber } from '../Subscriber'; import { Subscription } from '../Subscription'; import { async } from '../scheduler/async'; import { MonoTypeOperatorFunction, SchedulerLike, TeardownLogic } from '../types'; export function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> { return (source: Observable<T>) => source.lift(new DebounceTimeOperator(dueTime, scheduler)); } class DebounceTimeOperator<T> implements Operator<T, T> { constructor(private dueTime: number, private scheduler: SchedulerLike) { } call(subscriber: Subscriber<T>, source: any): TeardownLogic { return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler)); } } class DebounceTimeSubscriber<T> extends Subscriber<T> { private debouncedSubscription: Subscription = null; private lastValue: T = null; private hasValue: boolean = false; constructor(destination: Subscriber<T>, private dueTime: number, private scheduler: SchedulerLike) { super(destination); } protected _next(value: T) { this.clearDebounce(); this.lastValue = value; this.hasValue = true; this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this)); } protected _complete() { this.debouncedNext(); this.destination.complete(); } debouncedNext(): void { this.clearDebounce(); if (this.hasValue) { const { lastValue } = this; this.lastValue = null; this.hasValue = false; this.destination.next(lastValue); } } private clearDebounce(): void { const debouncedSubscription = this.debouncedSubscription; if (debouncedSubscription !== null) { this.remove(debouncedSubscription); debouncedSubscription.unsubscribe(); this.debouncedSubscription = null; } } } function dispatchNext(subscriber: DebounceTimeSubscriber<any>) { subscriber.debouncedNext(); }
export default function (options: { testing?: boolean; cliArgs: string[]; }): Promise<number>;
export declare class Log { logItems: any[]; constructor(); add(value: any ): void; fn(value: any ): (a1?: any, a2?: any, a3?: any, a4?: any, a5?: any) => void; clear(): void; result(): string; }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BRL': (string | undefined)[]; 'CNY': (string | undefined)[]; 'EGP': never[]; 'ESP': string[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NZD': (string | undefined)[]; 'RON': (string | undefined)[]; 'THB': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'XAF': never[]; 'XCD': (string | undefined)[]; 'XOF': never[]; } | undefined)[]; export default _default;
declare const _default: ({} | undefined)[]; export default _default;
import {patchMacroTask} from '../common/utils'; Zone.__load_patch('fs', () => { let fs: any; try { fs = require('fs'); } catch (err) { } const TO_PATCH_MACROTASK_METHODS = [ 'access', 'appendFile', 'chmod', 'chown', 'close', 'exists', 'fchmod', 'fchown', 'fdatasync', 'fstat', 'fsync', 'ftruncate', 'futimes', 'lchmod', 'lchown', 'link', 'lstat', 'mkdir', 'mkdtemp', 'open', 'read', 'readdir', 'readFile', 'readlink', 'realpath', 'rename', 'rmdir', 'stat', 'symlink', 'truncate', 'unlink', 'utimes', 'write', 'writeFile', ]; if (fs) { TO_PATCH_MACROTASK_METHODS.filter(name => !!fs[name] && typeof fs[name] === 'function') .forEach(name => { patchMacroTask(fs, name, (self: any, args: any[]) => { return { name: 'fs.' + name, args: args, cbIdx: args.length > 0 ? args.length - 1 : -1, target: self }; }); }); } });
export * from 'rxjs-compat/operators/bufferCount';
export { ChangeDetectionStrategy, ChangeDetectorRef, CollectionChangeRecord, DefaultIterableDiffer, IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, IterableDiffers, KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory, KeyValueDiffers, NgIterable, PipeTransform, SimpleChange, SimpleChanges, TrackByFunction, WrappedValue } from './change_detection/change_detection';
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export * from 'rxjs-compat/util/TimeoutError';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'ESP': string[]; 'EUR': (string | undefined)[]; 'FKP': (string | undefined)[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NZD': (string | undefined)[]; 'RON': (string | undefined)[]; 'SSP': (string | undefined)[]; 'SYP': (string | undefined)[]; 'TWD': (string | undefined)[]; 'USD': (string | undefined)[]; 'VEF': (string | undefined)[]; 'VND': (string | undefined)[]; 'XAF': never[]; 'XCD': (string | undefined)[]; 'XOF': never[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export * from './attachSession'; export * from './browserStack'; export * from './direct'; export * from './driverProvider'; export * from './hosted'; export * from './local'; export * from './mock'; export * from './sauce'; export * from './testObject'; export * from './kobiton'; export * from './useExistingWebDriver'; import { DriverProvider } from './driverProvider'; import { Config } from '../config'; export declare let buildDriverProvider: (config: Config) => DriverProvider; export declare let logWarnings: (providerType: string, config: Config) => void;
import { ProtractorPlugin } from 'protractor'; declare var module: any; let myPlugin: ProtractorPlugin = { addSuccess(info: {specName: string}) { console.log('on success: ' + info.specName); }, onPageLoad() { this.addSuccess({specName: 'Hello, World!'}); } }; module.exports = myPlugin;
export * from 'rxjs-compat/operators/exhaustMap';
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import { PipeTransform } from '@angular/core'; export declare class LowerCasePipe implements PipeTransform { transform(value: string): string; } export declare class TitleCasePipe implements PipeTransform { transform(value: string): string; } export declare class UpperCasePipe implements PipeTransform { transform(value: string): string; }
export * from 'rxjs-compat/observable/FromObservable';
export * from 'rxjs-compat/operator/exhaustMap';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import * as ts from 'typescript'; import { MetadataCache } from '../transformers/metadata_cache'; import { MetadataEntry, ModuleMetadata } from './schema'; export interface BundleEntries { [name: string]: MetadataEntry; } export interface BundlePrivateEntry { privateName: string; name: string; module: string; } export interface BundledModule { metadata: ModuleMetadata; privates: BundlePrivateEntry[]; } export interface MetadataBundlerHost { getMetadataFor(moduleName: string, containingFile: string): ModuleMetadata | undefined; } export declare class MetadataBundler { private root; private importAs; private host; private symbolMap; private metadataCache; private exports; private rootModule; private privateSymbolPrefix; private exported; constructor(root: string, importAs: string | undefined, host: MetadataBundlerHost, privateSymbolPrefix?: string); getMetadataBundle(): BundledModule; static resolveModule(importName: string, from: string): string; private getMetadata; private exportAll; private canonicalizeSymbols; private canonicalizeSymbol; private getEntries; private getReExports; private convertSymbol; private convertEntry; private convertClass; private convertMembers; private convertMember; private convertStatics; private convertFunction; private convertValue; private convertExpression; private convertError; private convertReference; private convertExpressionNode; private symbolOf; private canonicalSymbolOf; } export declare class CompilerHostAdapter implements MetadataBundlerHost { private host; private cache; private options; private collector; constructor(host: ts.CompilerHost, cache: MetadataCache | null, options: ts.CompilerOptions); getMetadataFor(fileName: string, containingFile: string): ModuleMetadata | undefined; }
export * from 'rxjs-compat/operators/switchMapTo';
import { Scheduler } from '../Scheduler'; import { Subscription } from '../Subscription'; import { SchedulerAction } from '../types'; export class Action<T> extends Subscription { constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) { super(); } public schedule(state?: T, delay: number = 0): Subscription { return this; } }
declare const _default: never[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; } | undefined)[]; export default _default;
export * from './public_api';
import { Binary, BinaryUrl } from '../binaries'; export declare class DownloadedBinary extends Binary { versions: string[]; binary: Binary; constructor(binary: Binary); id(): string; prefix(): string; suffix(): string; getUrl(): Promise<BinaryUrl>; getVersionList(): Promise<string[]>; }
import 'rxjs-compat/add/operator/sampleTime';
import { IRuleMetadata, RuleFailure, Rules, RuleWalker } from 'tslint/lib'; import { CallExpression, SourceFile } from 'typescript/lib/typescript'; export declare class Rule extends Rules.AbstractRule { static metadata: IRuleMetadata; static readonly FAILURE_STRING_CLASS: string; static readonly FAILURE_STRING_VARIABLE: string; apply(sourceFile: SourceFile): RuleFailure[]; } export declare class ExpressionCallMetadataWalker extends RuleWalker { visitCallExpression(node: CallExpression): void; private validateCallExpression; }
import { Injector, ModuleWithProviders } from '@angular/core'; import { Observable } from 'rxjs'; import { HttpBackend, HttpHandler } from './backend'; import { HttpInterceptor } from './interceptor'; import { HttpRequest } from './request'; import { HttpEvent } from './response'; export declare class HttpInterceptingHandler implements HttpHandler { private backend; private injector; private chain; constructor(backend: HttpBackend, injector: Injector); handle(req: HttpRequest<any>): Observable<HttpEvent<any>>; } export declare function interceptingHandler(backend: HttpBackend, interceptors?: HttpInterceptor[] | null): HttpHandler; export declare function jsonpCallbackContext(): Object; export declare class HttpClientXsrfModule { static disable(): ModuleWithProviders<HttpClientXsrfModule>; static withOptions(options?: { cookieName?: string; headerName?: string; }): ModuleWithProviders<HttpClientXsrfModule>; } export declare class HttpClientModule { } export declare class HttpClientJsonpModule { }
export { ajax } from '../internal/observable/dom/ajax'; export { AjaxRequest, AjaxResponse, AjaxError, AjaxTimeoutError } from '../internal/observable/dom/AjaxObservable';
export * from 'rxjs-compat/observable/IntervalObservable';
import { Operator } from '../Operator'; import { Subscriber } from '../Subscriber'; import { Observable } from '../Observable'; import { OperatorFunction, MonoTypeOperatorFunction, TeardownLogic } from '../types'; export function filter<T, S extends T>(predicate: (value: T, index: number) => value is S, thisArg?: any): OperatorFunction<T, S>; export function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T>; export function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T> { return function filterOperatorFunction(source: Observable<T>): Observable<T> { return source.lift(new FilterOperator(predicate, thisArg)); }; } class FilterOperator<T> implements Operator<T, T> { constructor(private predicate: (value: T, index: number) => boolean, private thisArg?: any) { } call(subscriber: Subscriber<T>, source: any): TeardownLogic { return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg)); } } class FilterSubscriber<T> extends Subscriber<T> { count: number = 0; constructor(destination: Subscriber<T>, private predicate: (value: T, index: number) => boolean, private thisArg: any) { super(destination); } protected _next(value: T) { let result: any; try { result = this.predicate.call(this.thisArg, value, this.count++); } catch (err) { this.destination.error(err); return; } if (result) { this.destination.next(value); } } }
import { Operator } from '../Operator'; import { Observable } from '../Observable'; import { Subscriber } from '../Subscriber'; import { OperatorFunction, MonoTypeOperatorFunction } from '../types'; export function defaultIfEmpty<T>(defaultValue?: T): MonoTypeOperatorFunction<T>; export function defaultIfEmpty<T, R>(defaultValue?: R): OperatorFunction<T, T | R>; export function defaultIfEmpty<T, R>(defaultValue: R = null): OperatorFunction<T, T | R> { return (source: Observable<T>) => source.lift(new DefaultIfEmptyOperator(defaultValue)) as Observable<T | R>; } class DefaultIfEmptyOperator<T, R> implements Operator<T, T | R> { constructor(private defaultValue: R) { } call(subscriber: Subscriber<T | R>, source: any): any { return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue)); } } class DefaultIfEmptySubscriber<T, R> extends Subscriber<T> { private isEmpty: boolean = true; constructor(destination: Subscriber<T | R>, private defaultValue: R) { super(destination); } protected _next(value: T): void { this.isEmpty = false; this.destination.next(value); } protected _complete(): void { if (this.isEmpty) { this.destination.next(this.defaultValue); } this.destination.complete(); } }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ETB': string[]; 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { ElementRef, Renderer2 } from '@angular/core'; import { ControlValueAccessor } from './control_value_accessor'; export declare const NUMBER_VALUE_ACCESSOR: any; export declare class NumberValueAccessor implements ControlValueAccessor { private _renderer; private _elementRef; onChange: (_: any) => void; onTouched: () => void; constructor(_renderer: Renderer2, _elementRef: ElementRef); writeValue(value: number): void; registerOnChange(fn: (_: number | null) => void): void; registerOnTouched(fn: () => void): void; setDisabledState(isDisabled: boolean): void; }
import { WebSocketSubject, WebSocketSubjectConfig } from './WebSocketSubject'; export function webSocket<T>(urlConfigOrSource: string | WebSocketSubjectConfig<T>): WebSocketSubject<T> { return new WebSocketSubject<T>(urlConfigOrSource); }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'TZS': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { Type } from '../type'; import { InjectionToken } from './injection_token'; import { StaticProvider } from './provider'; export declare const SOURCE = "__source"; export declare const THROW_IF_NOT_FOUND: Object; export declare const INJECTOR: InjectionToken<Injector>; export declare class NullInjector implements Injector { get(token: any, notFoundValue?: any): any; } export declare abstract class Injector { static THROW_IF_NOT_FOUND: Object; static NULL: Injector; abstract get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T; abstract get(token: any, notFoundValue?: any): any; static create(providers: StaticProvider[], parent?: Injector): Injector; static create(options: { providers: StaticProvider[]; parent?: Injector; name?: string; }): Injector; static ngInjectableDef: never; } export declare const USE_VALUE: string; export declare class StaticInjector implements Injector { readonly parent: Injector; readonly source: string | null; private _records; constructor(providers: StaticProvider[], parent?: Injector, source?: string | null); get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T; get(token: any, notFoundValue?: any): any; toString(): string; } export declare const enum InjectFlags { Default = 0, Host = 1, Self = 2, SkipSelf = 4, Optional = 8 } export declare function setCurrentInjector(injector: Injector | null | undefined): Injector | undefined | null; export declare function inject<T>(token: Type<T> | InjectionToken<T>): T; export declare function inject<T>(token: Type<T> | InjectionToken<T>, flags?: InjectFlags): T | null; export declare function injectArgs(types: (Type<any> | InjectionToken<any> | any[])[]): any[];
import * as o from './output/output_ast'; import { R3DependencyMetadata } from './render3/r3_factory'; export interface InjectableDef { expression: o.Expression; type: o.Type; statements: o.Statement[]; } export interface R3InjectableMetadata { name: string; type: o.Expression; ctorDeps: R3DependencyMetadata[] | null; providedIn: o.Expression; useClass?: o.Expression; useFactory?: o.Expression; useExisting?: o.Expression; useValue?: o.Expression; userDeps?: R3DependencyMetadata[]; } export declare function compileInjectable(meta: R3InjectableMetadata): InjectableDef;
import 'rxjs-compat/add/operator/retry';
import { Program } from '../cli'; export declare var program: Program;
import * as fs from 'fs'; export interface Options { readonly mode?: number; readonly fs?: typeof fs; } export default function makeDir( path: string, options?: Options ): Promise<string>; export function sync(path: string, options?: Options): string;
import 'rxjs-compat/add/operator/first';
export declare class ReadFileError extends Error { originalError: Error; constructor(originalError: Error); }
export * from './public_api';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
import { StaticProvider } from '../../di/provider'; export declare type NgIterable<T> = Array<T> | Iterable<T>; export interface IterableDiffer<V> { diff(object: NgIterable<V>): IterableChanges<V> | null; } export interface IterableChanges<V> { forEachItem(fn: (record: IterableChangeRecord<V>) => void): void; forEachOperation(fn: (record: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void; forEachPreviousItem(fn: (record: IterableChangeRecord<V>) => void): void; forEachAddedItem(fn: (record: IterableChangeRecord<V>) => void): void; forEachMovedItem(fn: (record: IterableChangeRecord<V>) => void): void; forEachRemovedItem(fn: (record: IterableChangeRecord<V>) => void): void; forEachIdentityChange(fn: (record: IterableChangeRecord<V>) => void): void; } export interface IterableChangeRecord<V> { readonly currentIndex: number | null; readonly previousIndex: number | null; readonly item: V; readonly trackById: any; } export interface CollectionChangeRecord<V> extends IterableChangeRecord<V> { } export interface TrackByFunction<T> { (index: number, item: T): any; } export interface IterableDifferFactory { supports(objects: any): boolean; create<V>(trackByFn?: TrackByFunction<V>): IterableDiffer<V>; } export declare class IterableDiffers { static ngInjectableDef: never; factories: IterableDifferFactory[]; constructor(factories: IterableDifferFactory[]); static create(factories: IterableDifferFactory[], parent?: IterableDiffers): IterableDiffers; static extend(factories: IterableDifferFactory[]): StaticProvider; find(iterable: any): IterableDifferFactory; } export declare function getTypeNameForDebugging(type: any): string;
import { Observable } from '../Observable'; import { Subscription } from '../Subscription'; import { observable as Symbol_observable } from '../symbol/observable'; import { subscribeToObservable } from '../util/subscribeToObservable'; import { InteropObservable, SchedulerLike, Subscribable } from '../types'; export function fromObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) { if (!scheduler) { return new Observable<T>(subscribeToObservable(input)); } else { return new Observable<T>(subscriber => { const sub = new Subscription(); sub.add(scheduler.schedule(() => { const observable: Subscribable<T> = input[Symbol_observable](); sub.add(observable.subscribe({ next(value) { sub.add(scheduler.schedule(() => subscriber.next(value))); }, error(err) { sub.add(scheduler.schedule(() => subscriber.error(err))); }, complete() { sub.add(scheduler.schedule(() => subscriber.complete())); }, })); })); return sub; }); } }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AED': string[]; 'ARS': (string | undefined)[]; 'AUD': string[]; 'BBD': (string | undefined)[]; 'BHD': string[]; 'BMD': (string | undefined)[]; 'BND': (string | undefined)[]; 'BSD': (string | undefined)[]; 'BZD': (string | undefined)[]; 'CAD': string[]; 'CLP': (string | undefined)[]; 'CNY': string[]; 'COP': (string | undefined)[]; 'CUP': (string | undefined)[]; 'DOP': (string | undefined)[]; 'DZD': string[]; 'EGP': string[]; 'FJD': (string | undefined)[]; 'GBP': string[]; 'GYD': (string | undefined)[]; 'HKD': string[]; 'IQD': string[]; 'IRR': string[]; 'JMD': (string | undefined)[]; 'JOD': string[]; 'JPY': string[]; 'KWD': string[]; 'KYD': (string | undefined)[]; 'LBP': string[]; 'LYD': string[]; 'MAD': string[]; 'MRO': string[]; 'MXN': string[]; 'NZD': string[]; 'OMR': string[]; 'QAR': string[]; 'SAR': string[]; 'SBD': (string | undefined)[]; 'SDD': string[]; 'SDG': string[]; 'SRD': (string | undefined)[]; 'SYP': string[]; 'THB': string[]; 'TND': string[]; 'TTD': (string | undefined)[]; 'TWD': string[]; 'USD': string[]; 'UYU': (string | undefined)[]; 'XXX': string[]; 'YER': string[]; } | undefined)[]; export default _default;
import { Type } from '@angular/core'; export { CheckboxControlValueAccessor } from './directives/checkbox_value_accessor'; export { ControlValueAccessor } from './directives/control_value_accessor'; export { DefaultValueAccessor } from './directives/default_value_accessor'; export { NgControl } from './directives/ng_control'; export { NgControlStatus, NgControlStatusGroup } from './directives/ng_control_status'; export { NgForm } from './directives/ng_form'; export { NG_FORM_SELECTOR_WARNING, NgFormSelectorWarning } from './directives/ng_form_selector_warning'; export { NgModel } from './directives/ng_model'; export { NgModelGroup } from './directives/ng_model_group'; export { NumberValueAccessor } from './directives/number_value_accessor'; export { RadioControlValueAccessor } from './directives/radio_control_value_accessor'; export { RangeValueAccessor } from './directives/range_value_accessor'; export { FormControlDirective, NG_MODEL_WITH_FORM_CONTROL_WARNING } from './directives/reactive_directives/form_control_directive'; export { FormControlName } from './directives/reactive_directives/form_control_name'; export { FormGroupDirective } from './directives/reactive_directives/form_group_directive'; export { FormArrayName, FormGroupName } from './directives/reactive_directives/form_group_name'; export { NgSelectOption, SelectControlValueAccessor } from './directives/select_control_value_accessor'; export { NgSelectMultipleOption, SelectMultipleControlValueAccessor } from './directives/select_multiple_control_value_accessor'; export declare const SHARED_FORM_DIRECTIVES: Type<any>[]; export declare const TEMPLATE_DRIVEN_DIRECTIVES: Type<any>[]; export declare const REACTIVE_DRIVEN_DIRECTIVES: Type<any>[]; export declare class InternalFormsSharedModule { }
import { Operator } from '../Operator'; import { Observable } from '../Observable'; import { Subscriber } from '../Subscriber'; import { OperatorFunction } from '../types'; export function pairwise<T>(): OperatorFunction<T, [T, T]> { return (source: Observable<T>) => source.lift(new PairwiseOperator()); } class PairwiseOperator<T> implements Operator<T, [T, T]> { call(subscriber: Subscriber<[T, T]>, source: any): any { return source.subscribe(new PairwiseSubscriber(subscriber)); } } class PairwiseSubscriber<T> extends Subscriber<T> { private prev: T; private hasPrev: boolean = false; constructor(destination: Subscriber<[T, T]>) { super(destination); } _next(value: T): void { if (this.hasPrev) { this.destination.next([this.prev, value]); } else { this.hasPrev = true; } this.prev = value; } }
export * from 'rxjs-compat/operator/toArray';
export * from 'rxjs-compat/Operator';
import { HttpRequest } from '@angular/common/http'; import { TestRequest } from './request'; export interface RequestMatch { method?: string; url?: string; } export declare abstract class HttpTestingController { abstract match(match: string | RequestMatch | ((req: HttpRequest<any>) => boolean)): TestRequest[]; abstract expectOne(url: string, description?: string): TestRequest; abstract expectOne(params: RequestMatch, description?: string): TestRequest; abstract expectOne(matchFn: ((req: HttpRequest<any>) => boolean), description?: string): TestRequest; abstract expectOne(match: string | RequestMatch | ((req: HttpRequest<any>) => boolean), description?: string): TestRequest; abstract expectNone(url: string, description?: string): void; abstract expectNone(params: RequestMatch, description?: string): void; abstract expectNone(matchFn: ((req: HttpRequest<any>) => boolean), description?: string): void; abstract expectNone(match: string | RequestMatch | ((req: HttpRequest<any>) => boolean), description?: string): void; abstract verify(opts?: { ignoreCancelled?: boolean; }): void; }
import { ChildProcess } from 'child_process'; import * as q from 'q'; import { Config } from './config'; export declare class BlockingProxyRunner { private config; bpProcess: ChildProcess; port: number; constructor(config: Config); start(): q.Promise<{}>; checkSupportedConfig(): void; }
import 'rxjs-compat/add/operator/publishBehavior';
export * from './testing/testing';
import * as ts from 'typescript'; import { Maybe } from './function'; export declare function getAnimations(dec: ts.Decorator): Maybe<ts.ArrayLiteralExpression | undefined>; export declare function getInlineStyle(dec: ts.Decorator): Maybe<ts.ArrayLiteralExpression | undefined>; export declare function getTemplate(dec: ts.Decorator): Maybe<ts.StringLiteral | undefined>; export declare function getTemplateUrl(dec: ts.Decorator): Maybe<ts.StringLiteral | undefined>;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'KES': string[]; 'THB': string[]; 'TWD': string[]; 'TZS': string[]; 'UGX': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export declare class ErrorHandler { handleError(error: any): void; } export declare function wrappedError(message: string, originalError: any): Error;
export * from 'rxjs-compat/operators/single';
import { Scheduler } from '../Scheduler'; import { SubscriptionLog } from './SubscriptionLog'; export class SubscriptionLoggable { public subscriptions: SubscriptionLog[] = []; scheduler: Scheduler; logSubscribedFrame(): number { this.subscriptions.push(new SubscriptionLog(this.scheduler.now())); return this.subscriptions.length - 1; } logUnsubscribedFrame(index: number) { const subscriptionLogs = this.subscriptions; const oldSubscriptionLog = subscriptionLogs[index]; subscriptionLogs[index] = new SubscriptionLog( oldSubscriptionLog.subscribedFrame, this.scheduler.now() ); } }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': string[]; 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import * as ts from 'typescript'; import { ReflectionHost } from '../../host'; import { IvyCompilation } from './compilation'; export declare function ivyTransformFactory(compilation: IvyCompilation, reflector: ReflectionHost, coreImportsFrom: ts.SourceFile | null): ts.TransformerFactory<ts.SourceFile>;
import { concatMap } from './concatMap'; import { ObservableInput, OperatorFunction } from '../types'; export function concatMapTo<T>(observable: ObservableInput<T>): OperatorFunction<any, T>; export function concatMapTo<T>(observable: ObservableInput<T>, resultSelector: undefined): OperatorFunction<any, T>; export function concatMapTo<T, I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>; export function concatMapTo<T, I, R>( innerObservable: ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R ): OperatorFunction<T, R> { return concatMap(() => innerObservable, resultSelector); }
export * from 'rxjs-compat/observable/NeverObservable';
export * from 'rxjs-compat/operator/timeout';
import { Provider } from '@angular/core'; import { DeprecatedDatePipe } from './date_pipe'; import { DeprecatedCurrencyPipe, DeprecatedDecimalPipe, DeprecatedPercentPipe } from './number_pipe'; export { DeprecatedCurrencyPipe, DeprecatedDatePipe, DeprecatedDecimalPipe, DeprecatedPercentPipe, }; export declare const COMMON_DEPRECATED_I18N_PIPES: Provider[];
import { ApplicationRef } from '../application_ref'; import { ChangeDetectorRef as viewEngine_ChangeDetectorRef } from '../change_detection/change_detector_ref'; import { ViewContainerRef as viewEngine_ViewContainerRef } from '../linker/view_container_ref'; import { EmbeddedViewRef as viewEngine_EmbeddedViewRef, InternalViewRef as viewEngine_InternalViewRef } from '../linker/view_ref'; import { LViewData } from './interfaces/view'; export interface viewEngine_ChangeDetectorRef_interface extends viewEngine_ChangeDetectorRef { } export declare class ViewRef<T> implements viewEngine_EmbeddedViewRef<T>, viewEngine_InternalViewRef, viewEngine_ChangeDetectorRef_interface { private _context; private _componentIndex; private _appRef; private _viewContainerRef; rootNodes: any[]; constructor(_view: LViewData, _context: T | null, _componentIndex: number); readonly context: T; readonly destroyed: boolean; destroy(): void; onDestroy(callback: Function): void; markForCheck(): void; detach(): void; reattach(): void; detectChanges(): void; checkNoChanges(): void; attachToViewContainerRef(vcRef: viewEngine_ViewContainerRef): void; detachFromAppRef(): void; attachToAppRef(appRef: ApplicationRef): void; private _lookUpContext; }
import { Renderer2, RendererType2 } from '../render/api'; import { DebugRendererFactory2 } from '../view/services'; export declare class Render3DebugRendererFactory2 extends DebugRendererFactory2 { createRenderer(element: any, renderData: RendererType2 | null): Renderer2; }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export * from 'rxjs-compat/operators/timeout';
export declare class TaskLogger { private task; private pid; private buffer; private insertTag; constructor(task: any, pid: number); private logHeader_(); peek(): void; flush(): void; log(data: string): void; }
declare function now(): number; export = now;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'KZT': string[]; 'RUB': string[]; 'THB': string[]; 'TWD': string[]; } | undefined)[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; 'XCD': string[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export * from 'rxjs-compat/util/UnsubscriptionError';
import { StyleSanitizeFn } from './style_sanitizer'; export declare function sanitizeHtml(unsafeHtml: any): string; export declare function sanitizeStyle(unsafeStyle: any): string; export declare function sanitizeUrl(unsafeUrl: any): string; export declare function sanitizeResourceUrl(unsafeResourceUrl: any): string; export declare function sanitizeScript(unsafeScript: any): string; export declare const defaultStyleSanitizer: StyleSanitizeFn;
declare const _default: never[]; export default _default;
export * from 'rxjs-compat/operators/zipAll';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'ESP': string[]; 'EUR': (string | undefined)[]; 'FKP': (string | undefined)[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'HNL': string[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NZD': (string | undefined)[]; 'RON': (string | undefined)[]; 'SSP': (string | undefined)[]; 'SYP': (string | undefined)[]; 'TWD': (string | undefined)[]; 'USD': (string | undefined)[]; 'VEF': (string | undefined)[]; 'VND': (string | undefined)[]; 'XAF': never[]; 'XCD': (string | undefined)[]; 'XOF': never[]; } | undefined)[]; export default _default;
import { DisplayProcessor } from "../display-processor"; import { CustomReporterResult } from "../spec-reporter"; export declare class SuiteNumberingProcessor extends DisplayProcessor { private static getParentName(element); private suiteHierarchy; displaySuite(suite: CustomReporterResult, log: string): string; private computeNumber(suite); private computeHierarchy(suite); private computeHierarchyNumber(); }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'KES': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { Command } from '../models/command'; import { Schema as EjectCommandSchema } from './eject'; export declare class EjectCommand extends Command<EjectCommandSchema> { run(): Promise<number>; }
declare const _default: never[]; export default _default;
import { mergeMap } from './mergeMap'; import { ObservableInput, OperatorFunction } from '../types'; export function concatMap<T, R>(project: (value: T, index: number) => ObservableInput<R>): OperatorFunction<T, R>; export function concatMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, resultSelector: undefined): OperatorFunction<T, R>; export function concatMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>; export function concatMap<T, I, R>( project: (value: T, index: number) => ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R ): OperatorFunction<T, I|R> { return mergeMap(project, resultSelector, 1); }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ATS': string[]; 'AUD': string[]; 'BGM': string[]; 'BGO': string[]; 'CUC': (string | undefined)[]; 'DEM': string[]; 'EUR': never[]; 'FKP': (string | undefined)[]; 'GNF': (string | undefined)[]; 'KMF': (string | undefined)[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SYP': never[]; 'THB': string[]; 'TWD': string[]; 'ZMW': (string | undefined)[]; })[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AED': string[]; 'ARS': (string | undefined)[]; 'AUD': string[]; 'BBD': (string | undefined)[]; 'BHD': string[]; 'BMD': (string | undefined)[]; 'BND': (string | undefined)[]; 'BSD': (string | undefined)[]; 'BZD': (string | undefined)[]; 'CAD': string[]; 'CLP': (string | undefined)[]; 'CNY': string[]; 'COP': (string | undefined)[]; 'CUP': (string | undefined)[]; 'DOP': (string | undefined)[]; 'DZD': string[]; 'EGP': string[]; 'FJD': (string | undefined)[]; 'GBP': string[]; 'GYD': (string | undefined)[]; 'HKD': string[]; 'IQD': string[]; 'IRR': string[]; 'JMD': (string | undefined)[]; 'JOD': string[]; 'JPY': string[]; 'KWD': string[]; 'KYD': (string | undefined)[]; 'LBP': string[]; 'LYD': string[]; 'MAD': string[]; 'MRO': string[]; 'MXN': string[]; 'NZD': string[]; 'OMR': string[]; 'QAR': string[]; 'SAR': string[]; 'SBD': (string | undefined)[]; 'SDD': string[]; 'SDG': string[]; 'SRD': (string | undefined)[]; 'SYP': string[]; 'THB': string[]; 'TND': string[]; 'TTD': (string | undefined)[]; 'TWD': string[]; 'USD': string[]; 'UYU': (string | undefined)[]; 'XXX': string[]; 'YER': string[]; } | undefined)[]; export default _default;
export { ErrorCode } from './src/code'; export { FatalDiagnosticError, isFatalDiagnosticError } from './src/error'; export { replaceTsWithNgInErrors } from './src/util';
export interface TimeoutError extends Error { } export interface TimeoutErrorCtor { new(): TimeoutError; } function TimeoutErrorImpl(this: any) { Error.call(this); this.message = 'Timeout has occurred'; this.name = 'TimeoutError'; return this; } TimeoutErrorImpl.prototype = Object.create(Error.prototype); export const TimeoutError: TimeoutErrorCtor = TimeoutErrorImpl as any;
export * from 'rxjs-compat/operator/share';
export * from 'rxjs-compat/Subscription';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'DKK': string[]; 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { NgModule } from '@angular/core'; import { Routes, RouterModule } from '@angular/router'; const routes: Routes = []; @NgModule({ imports: [RouterModule.for<%= routingScope %>(routes)], exports: [RouterModule] }) export class <%= classify(name) %>RoutingModule { }
import 'rxjs-compat/add/operator/shareReplay';
export declare abstract class ConfigSource { ostype: string; osarch: string; out_dir: string; abstract getUrl(version: string): Promise<{ url: string; version: string; }>; abstract getVersionList(): Promise<string[]>; } export declare abstract class XmlConfigSource extends ConfigSource { name: string; xmlUrl: string; constructor(name: string, xmlUrl: string); protected getFileName(): string; protected getXml(): Promise<any>; private readResponse(); private requestXml(); private convertXml2js(xml); } export declare abstract class JsonConfigSource extends ConfigSource { name: string; jsonUrl: string; constructor(name: string, jsonUrl: string); protected getFileName(): string; protected abstract getJson(): Promise<string>; } export declare abstract class GithubApiConfigSource extends JsonConfigSource { constructor(name: string, url: string); getJson(): Promise<any>; private requestJson(); private readResponse(); }
export {};
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': string[]; 'CAD': string[]; 'FJD': string[]; 'JPY': string[]; 'SBD': string[]; 'THB': string[]; 'TWD': string[]; 'XPF': never[]; } | undefined)[]; export default _default;
import { Injector } from '../di/injector'; import { Type } from '../type'; import { ComponentFactory, ComponentRef } from './component_factory'; import { NgModuleRef } from './ng_module_factory'; export declare function noComponentFactoryError(component: Function): Error; export declare function getComponent(error: Error): Type<any>; export declare abstract class ComponentFactoryResolver { static NULL: ComponentFactoryResolver; abstract resolveComponentFactory<T>(component: Type<T>): ComponentFactory<T>; } export declare class CodegenComponentFactoryResolver implements ComponentFactoryResolver { private _parent; private _ngModule; private _factories; constructor(factories: ComponentFactory<any>[], _parent: ComponentFactoryResolver, _ngModule: NgModuleRef<any>); resolveComponentFactory<T>(component: { new (...args: any[]): T; }): ComponentFactory<T>; } export declare class ComponentFactoryBoundToModule<C> extends ComponentFactory<C> { private factory; private ngModule; readonly selector: string; readonly componentType: Type<any>; readonly ngContentSelectors: string[]; readonly inputs: { propName: string; templateName: string; }[]; readonly outputs: { propName: string; templateName: string; }[]; constructor(factory: ComponentFactory<C>, ngModule: NgModuleRef<any>); create(injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string | any, ngModule?: NgModuleRef<any>): ComponentRef<C>; }
import { SchedulerLike } from '../types'; import { isScheduler } from '../util/isScheduler'; import { fromArray } from './fromArray'; import { empty } from './empty'; import { scalar } from './scalar'; import { Observable } from '../Observable'; export function of<T>(a: T, scheduler?: SchedulerLike): Observable<T>; export function of<T, T2>(a: T, b: T2, scheduler?: SchedulerLike): Observable<T | T2>; export function of<T, T2, T3>(a: T, b: T2, c: T3, scheduler?: SchedulerLike): Observable<T | T2 | T3>; export function of<T, T2, T3, T4>(a: T, b: T2, c: T3, d: T4, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>; export function of<T, T2, T3, T4, T5>(a: T, b: T2, c: T3, d: T4, e: T5, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>; export function of<T, T2, T3, T4, T5, T6>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>; export function of<T, T2, T3, T4, T5, T6, T7>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6 | T7>; export function of<T, T2, T3, T4, T5, T6, T7, T8>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8>; export function of<T, T2, T3, T4, T5, T6, T7, T8, T9>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, i: T9, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>; export function of<T>(...args: Array<T | SchedulerLike>): Observable<T>; export function of<T>(...args: Array<T | SchedulerLike>): Observable<T> { let scheduler = args[args.length - 1] as SchedulerLike; if (isScheduler(scheduler)) { args.pop(); } else { scheduler = undefined; } switch (args.length) { case 0: return empty(scheduler); case 1: return scheduler ? fromArray(args as T[], scheduler) : scalar(args[0] as T); default: return fromArray(args as T[], scheduler); } }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export declare const FormErrorExamples: { formControlName: string; formGroupName: string; formArrayName: string; ngModelGroup: string; ngModelWithFormGroup: string; };
export interface Schema { commit?: CommitUnion; createApplication?: boolean; directory?: string; experimentalIvy?: boolean; inlineStyle?: boolean; inlineTemplate?: boolean; linkCli?: boolean; minimal?: boolean; name: string; newProjectRoot?: string; prefix?: string; routing?: boolean; skipGit?: boolean; skipInstall?: boolean; skipTests?: boolean; style?: string; version: string; viewEncapsulation?: ViewEncapsulation; } export declare type CommitUnion = boolean | CommitObject; export interface CommitObject { email: string; message?: string; name: string; } export declare enum ViewEncapsulation { Emulated = "Emulated", Native = "Native", None = "None", ShadowDOM = "ShadowDom" }
export * from 'rxjs-compat/observable/TimerObservable';
export * from 'rxjs-compat/operator/delayWhen';
import { TemplateRef, ViewContainerRef } from '@angular/core'; export declare class NgIf { private _viewContainer; private _context; private _thenTemplateRef; private _elseTemplateRef; private _thenViewRef; private _elseViewRef; constructor(_viewContainer: ViewContainerRef, templateRef: TemplateRef<NgIfContext>); ngIf: any; ngIfThen: TemplateRef<NgIfContext> | null; ngIfElse: TemplateRef<NgIfContext> | null; private _updateView; static ngTemplateGuard_ngIf<E>(dir: NgIf, expr: E): expr is NonNullable<E>; } export declare class NgIfContext { $implicit: any; ngIf: any; }
import { Configuration } from "../configuration"; import { CustomReporterResult } from "../custom-reporter-result"; import SuiteInfo = jasmine.SuiteInfo; export declare class DisplayProcessor { protected configuration: Configuration; constructor(configuration: Configuration); displayJasmineStarted(info: SuiteInfo, log: String): String; displaySuite(suite: CustomReporterResult, log: String): String; displaySpecStarted(spec: CustomReporterResult, log: String): String; displaySuccessfulSpec(spec: CustomReporterResult, log: String): String; displayFailedSpec(spec: CustomReporterResult, log: String): String; displaySpecErrorMessages(spec: CustomReporterResult, log: String): String; displaySummaryErrorMessages(spec: CustomReporterResult, log: String): String; displayPendingSpec(spec: CustomReporterResult, log: String): String; }
import 'rxjs-compat/add/operator/window';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'BDT': string[]; 'JPY': string[]; 'THB': string[]; 'TWD': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { CompileReflector } from '../compile_reflector'; import * as o from './output_ast'; export declare function interpretStatements(statements: o.Statement[], reflector: CompileReflector): { [key: string]: any; };
export * from 'rxjs-compat/operators/delayWhen';
const equal: (a: any, b: any) => boolean; export = equal;
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING(lineCount: number, lineLimit: number): string; isEnabled(): boolean; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'GBP': string[]; 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import 'rxjs-compat/add/observable/if';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
import { Observable } from '../Observable'; import { MonoTypeOperatorFunction } from '../types'; export declare function takeUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T>;
import { ArchitectCommand } from '../models/architect-command'; import { Arguments } from '../models/interface'; import { Schema as E2eCommandSchema } from './e2e'; export declare class E2eCommand extends ArchitectCommand<E2eCommandSchema> { readonly target = "e2e"; readonly multiTarget = true; run(options: E2eCommandSchema & Arguments): Promise<number>; }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import { Observable } from '../Observable'; import { Subject } from '../Subject'; import { multicast } from './multicast'; import { ConnectableObservable } from '../observable/ConnectableObservable'; import { MonoTypeOperatorFunction, OperatorFunction, UnaryFunction } from '../types'; export function publish<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>>; export function publish<T, R>(selector: OperatorFunction<T, R>): OperatorFunction<T, R>; export function publish<T>(selector: MonoTypeOperatorFunction<T>): MonoTypeOperatorFunction<T>; export function publish<T, R>(selector?: OperatorFunction<T, R>): MonoTypeOperatorFunction<T> | OperatorFunction<T, R> { return selector ? multicast(() => new Subject<T>(), selector) : multicast(new Subject<T>()); }
import { Component } from './directives'; export declare function resolveComponentResources(resourceResolver: (url: string) => (Promise<string | { text(): Promise<string>; }>)): Promise<null>; export declare function maybeQueueResolutionOfComponentResources(metadata: Component): void; export declare function componentNeedsResolution(component: Component): string | number | undefined; export declare function clearResolutionOfComponentResourcesQueue(): void;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'ESP': string[]; 'EUR': (string | undefined)[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NZD': (string | undefined)[]; 'TWD': (string | undefined)[]; 'VEF': (string | undefined)[]; 'VND': (string | undefined)[]; 'XAF': never[]; 'XCD': (string | undefined)[]; 'XOF': never[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/operators/expand';
import 'rxjs-compat/add/observable/combineLatest';
export * from 'rxjs-compat/util/subscribeToPromise';
import 'rxjs-compat/add/operator/timeoutWith';
export const environment = { production: false };
import { Component } from './core'; import * as o from './output/output_ast'; export declare abstract class CompileReflector { abstract parameters(typeOrFunc: any): any[][]; abstract annotations(typeOrFunc: any): any[]; abstract shallowAnnotations(typeOrFunc: any): any[]; abstract tryAnnotations(typeOrFunc: any): any[]; abstract propMetadata(typeOrFunc: any): { [key: string]: any[]; }; abstract hasLifecycleHook(type: any, lcProperty: string): boolean; abstract guards(typeOrFunc: any): { [key: string]: any; }; abstract componentModuleUrl(type: any, cmpMetadata: Component): string; abstract resolveExternalReference(ref: o.ExternalReference): any; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/operator/find';
export declare class QueryEncoder { encodeKey(key: string): string; encodeValue(value: string): string; } export declare class URLSearchParams { rawParams: string; private queryEncoder; paramsMap: Map<string, string[]>; constructor(rawParams?: string, queryEncoder?: QueryEncoder); clone(): URLSearchParams; has(param: string): boolean; get(param: string): string | null; getAll(param: string): string[]; set(param: string, val: string): void; setAll(searchParams: URLSearchParams): void; append(param: string, val: string): void; appendAll(searchParams: URLSearchParams): void; replaceAll(searchParams: URLSearchParams): void; toString(): string; delete(param: string): void; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AED': string[]; 'ARS': (string | undefined)[]; 'AUD': string[]; 'BBD': (string | undefined)[]; 'BHD': string[]; 'BMD': (string | undefined)[]; 'BND': (string | undefined)[]; 'BSD': (string | undefined)[]; 'BZD': (string | undefined)[]; 'CAD': string[]; 'CLP': (string | undefined)[]; 'CNY': string[]; 'COP': (string | undefined)[]; 'CUP': (string | undefined)[]; 'DOP': (string | undefined)[]; 'DZD': string[]; 'EGP': string[]; 'FJD': (string | undefined)[]; 'GBP': string[]; 'GYD': (string | undefined)[]; 'HKD': string[]; 'IQD': string[]; 'IRR': string[]; 'JMD': (string | undefined)[]; 'JOD': string[]; 'JPY': string[]; 'KWD': string[]; 'KYD': (string | undefined)[]; 'LBP': string[]; 'LYD': string[]; 'MAD': string[]; 'MRO': string[]; 'MXN': string[]; 'NZD': string[]; 'OMR': string[]; 'QAR': string[]; 'SAR': string[]; 'SBD': (string | undefined)[]; 'SDD': string[]; 'SDG': string[]; 'SRD': (string | undefined)[]; 'SYP': string[]; 'THB': string[]; 'TND': string[]; 'TTD': (string | undefined)[]; 'TWD': string[]; 'USD': string[]; 'UYU': (string | undefined)[]; 'XXX': string[]; 'YER': string[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export * from './http/http';
export * from 'rxjs-compat/operators/isEmpty';
import { MonoTypeOperatorFunction, SchedulerLike } from '../types'; export declare function subscribeOn<T>(scheduler: SchedulerLike, delay?: number): MonoTypeOperatorFunction<T>;
export * from 'rxjs-compat/operators/debounceTime';
declare const _default: never[]; export default _default;
export * from 'rxjs-compat/operators/take';
Zone.__load_patch('RTCPeerConnection', (global: any, Zone: ZoneType, api: _ZonePrivate) => { const RTCPeerConnection = global['RTCPeerConnection']; if (!RTCPeerConnection) { return; } const addSymbol = api.symbol('addEventListener'); const removeSymbol = api.symbol('removeEventListener'); RTCPeerConnection.prototype.addEventListener = RTCPeerConnection.prototype[addSymbol]; RTCPeerConnection.prototype.removeEventListener = RTCPeerConnection.prototype[removeSymbol]; RTCPeerConnection.prototype[addSymbol] = null; RTCPeerConnection.prototype[removeSymbol] = null; api.patchEventTarget(global, [RTCPeerConnection.prototype], {useG: false}); });
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
import * as ast from '@angular/compiler'; import { FlatSymbolTable } from './recursiveAngularExpressionVisitor'; export declare class ReferenceCollectorVisitor implements ast.TemplateAstVisitor { private _variables; visit?(node: ast.TemplateAst, context: any): FlatSymbolTable; visitBoundText(text: ast.BoundTextAst, context: any): any; visitElementProperty(prop: ast.BoundElementPropertyAst, context: any): any; visitReference(ast: ast.ReferenceAst, context: any): any; visitNgContent(ast: ast.NgContentAst, context: any): any; visitVariable(ast: ast.VariableAst, context: any): any; visitAttr(ast: ast.AttrAst, context: any): any; visitText(text: ast.TextAst, context: any): any; visitDirective(ast: ast.DirectiveAst, context: any): any; visitDirectiveProperty(ast: ast.BoundDirectivePropertyAst, context: any): any; visitEvent(ast: ast.BoundEventAst, context: any): any; visitEmbeddedTemplate(ast: ast.EmbeddedTemplateAst, context: any): any; visitElement(element: ast.ElementAst, context: any): any; readonly variables: FlatSymbolTable; }
export * from './browser';
export * from 'rxjs-compat/observable/RangeObservable';
import { Operator } from './Operator'; import { Observable } from './Observable'; import { Subscriber } from './Subscriber'; import { Subscription } from './Subscription'; import { Observer, SubscriptionLike, TeardownLogic } from './types'; export declare class SubjectSubscriber<T> extends Subscriber<T> { protected destination: Subject<T>; constructor(destination: Subject<T>); } export declare class Subject<T> extends Observable<T> implements SubscriptionLike { observers: Observer<T>[]; closed: boolean; isStopped: boolean; hasError: boolean; thrownError: any; constructor(); static create: Function; lift<R>(operator: Operator<T, R>): Observable<R>; next(value?: T): void; error(err: any): void; complete(): void; unsubscribe(): void; _trySubscribe(subscriber: Subscriber<T>): TeardownLogic; _subscribe(subscriber: Subscriber<T>): Subscription; asObservable(): Observable<T>; } export declare class AnonymousSubject<T> extends Subject<T> { protected destination?: Observer<T>; constructor(destination?: Observer<T>, source?: Observable<T>); next(value: T): void; error(err: any): void; complete(): void; _subscribe(subscriber: Subscriber<T>): Subscription; }
export * from 'rxjs-compat/operator/do';
import { MissingTranslationStrategy } from '../core'; export interface AotCompilerOptions { locale?: string; i18nFormat?: string; translations?: string; missingTranslation?: MissingTranslationStrategy; enableSummariesForJit?: boolean; preserveWhitespaces?: boolean; fullTemplateTypeCheck?: boolean; allowEmptyCodegenFiles?: boolean; strictInjectionParameters?: boolean; enableIvy?: boolean | 'ngtsc' | 'tsc'; }
export * from './upgrade/upgrade';
import 'rxjs-compat/add/operator/exhaust';
import 'rxjs-compat/add/operator/timestamp';
export * from 'rxjs-compat/operator/publishBehavior';
import * as i18n from '../i18n_ast'; import { Serializer } from './serializer'; export declare class Xliff extends Serializer { write(messages: i18n.Message[], locale: string | null): string; load(content: string, url: string): { locale: string; i18nNodesByMsgId: { [msgId: string]: i18n.Node[]; }; }; digest(message: i18n.Message): string; }
export { EmptyOutletComponent as ɵEmptyOutletComponent } from './components/empty_outlet'; export { ROUTER_PROVIDERS as ɵROUTER_PROVIDERS } from './router_module'; export { flatten as ɵflatten } from './utils/collection';
import { ViewportScroller } from '@angular/common'; import { OnDestroy } from '@angular/core'; import { Router } from './router'; export declare class RouterScroller implements OnDestroy { private router; readonly viewportScroller: ViewportScroller; private options; private routerEventsSubscription; private scrollEventsSubscription; private lastId; private lastSource; private restoredId; private store; constructor(router: Router, viewportScroller: ViewportScroller, options?: { scrollPositionRestoration?: 'disabled' | 'enabled' | 'top'; anchorScrolling?: 'disabled' | 'enabled'; }); init(): void; private createScrollEvents; private consumeScrollEvents; private scheduleScrollEvent; ngOnDestroy(): void; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING_FACTORY(lineLimit: number): string; isEnabled(): boolean; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; private getRuleOptions; }
import * as ts from "typescript"; import { IWalker, WalkContext } from "../walker"; import { IOptions, IRule, IRuleMetadata, RuleFailure, RuleSeverity } from "./rule"; export declare type NoInfer<T> = T & { [K in keyof T]: T[K]; }; export declare abstract class AbstractRule implements IRule { private readonly options; static metadata: IRuleMetadata; protected readonly ruleArguments: any[]; protected readonly ruleSeverity: RuleSeverity; ruleName: string; constructor(options: IOptions); getOptions(): IOptions; abstract apply(sourceFile: ts.SourceFile): RuleFailure[]; applyWithWalker(walker: IWalker): RuleFailure[]; isEnabled(): boolean; protected applyWithFunction(sourceFile: ts.SourceFile, walkFn: (ctx: WalkContext<void>) => void): RuleFailure[]; protected applyWithFunction<T>(sourceFile: ts.SourceFile, walkFn: (ctx: WalkContext<T>) => void, options: NoInfer<T>): RuleFailure[]; protected applyWithFunction<T, U>(sourceFile: ts.SourceFile, walkFn: (ctx: WalkContext<T>, programOrChecker: U) => void, options: NoInfer<T>, checker: NoInfer<U>): RuleFailure[]; protected filterFailures(failures: RuleFailure[]): RuleFailure[]; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import { ɵStyleData } from '@angular/animations'; import { AnimationEngineInstruction } from '../render/animation_engine_instruction'; import { AnimationTimelineInstruction } from './animation_timeline_instruction'; export interface AnimationTransitionInstruction extends AnimationEngineInstruction { element: any; triggerName: string; isRemovalTransition: boolean; fromState: string; fromStyles: ɵStyleData; toState: string; toStyles: ɵStyleData; timelines: AnimationTimelineInstruction[]; queriedElements: any[]; preStyleProps: Map<any, { [prop: string]: boolean; }>; postStyleProps: Map<any, { [prop: string]: boolean; }>; totalTime: number; errors?: any[]; } export declare function createTransitionInstruction(element: any, triggerName: string, fromState: string, toState: string, isRemovalTransition: boolean, fromStyles: ɵStyleData, toStyles: ɵStyleData, timelines: AnimationTimelineInstruction[], queriedElements: any[], preStyleProps: Map<any, { [prop: string]: boolean; }>, postStyleProps: Map<any, { [prop: string]: boolean; }>, totalTime: number, errors?: any[]): AnimationTransitionInstruction;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import * as html from '../ml_parser/ast'; import { ParseError } from '../parse_util'; import { BindingParser } from '../template_parser/binding_parser'; import * as t from './r3_ast'; export declare type Render3ParseResult = { nodes: t.Node[]; errors: ParseError[]; ngContentSelectors: string[]; hasNgContent: boolean; }; export declare function htmlAstToRender3Ast(htmlNodes: html.Node[], bindingParser: BindingParser): Render3ParseResult;
export * from './src/platform-browser';
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare const _default: never[]; export default _default;
export declare class ShadowCss { strictStyling: boolean; constructor(); shimCssText(cssText: string, selector: string, hostSelector?: string): string; private _insertDirectives; private _insertPolyfillDirectivesInCssText; private _insertPolyfillRulesInCssText; private _scopeCssText; private _extractUnscopedRulesFromCssText; private _convertColonHost; private _convertColonHostContext; private _convertColonRule; private _colonHostContextPartReplacer; private _colonHostPartReplacer; private _convertShadowDOMSelectors; private _scopeSelectors; private _scopeSelector; private _selectorNeedsScoping; private _makeScopeMatcher; private _applySelectorScope; private _applySimpleSelectorScope; private _insertPolyfillHostInCssText; } export declare class CssRule { selector: string; content: string; constructor(selector: string, content: string); } export declare function processRules(input: string, ruleCallback: (rule: CssRule) => CssRule): string;
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.TypedRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING(name: string, message: string): string; applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): Lint.RuleFailure[]; }
export declare class Version { full: string; readonly major: string; readonly minor: string; readonly patch: string; constructor(full: string); } export declare const VERSION: Version;
declare const _default: (string | string[])[][]; export default _default;
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import { RawSourceMap } from 'source-map'; export interface Options { sideEffectFreeModules?: string[]; } export default function optimizer(options: Options): { name: string; transform: (content: string, id: string) => { code: string; map: RawSourceMap; } | null; };
import { PartialModule } from '@angular/compiler'; import * as ts from 'typescript'; import { MetadataTransformer, ValueTransform } from './metadata_cache'; export declare class PartialModuleMetadataTransformer implements MetadataTransformer { private moduleMap; constructor(modules: PartialModule[]); start(sourceFile: ts.SourceFile): ValueTransform | undefined; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_NO_SPACE: string; static FAILURE_NEEDS_SPACE(count: number): string; static FAILURE_NO_EXTRA_SPACE(count: number): string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.TypedRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING(negate: boolean): string; applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): Lint.RuleFailure[]; }
import { JsonValue } from '@angular-devkit/core'; export declare function readFile(fileName: string): string; export declare function readJsonFile(path: string): JsonValue;
export { mainNgcc } from './src/main';
declare function flatten <T> (array: flatten.NestedArray<T>): T[]; declare namespace flatten { export interface NestedArray <T> extends ReadonlyArray<T | NestedArray<T>> {} export interface NestedList <T> { [index: number]: T | NestedList<T>; length: number; } export function from <T> (array: NestedList<T>): T[]; export function depth <T> (array: NestedArray<T>, depth: number): NestedArray<T>; export function depthFrom <T> (array: NestedList<T>, depth: number): NestedArray<T>; } export = flatten;
export declare class LinkedList<T extends { next: T | null; }> { private _head; constructor(_head: T); get(l: number): T | null; readonly head: T; readonly length: number; reduce<R>(accumulator: (acc: R, value: T, index?: number) => R, seed: R): R; find(predicate: (value: T, index?: number) => boolean): T | null; forEach(visitor: (value: T, index?: number) => void): void; }
import { AbstractFormatter } from "../language/formatter/abstractFormatter"; import { IFormatterMetadata } from "../language/formatter/formatter"; import { RuleFailure } from "../language/rule/rule"; export declare class Formatter extends AbstractFormatter { static metadata: IFormatterMetadata; format(failures: RuleFailure[]): string; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.TypedRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): Lint.RuleFailure[]; }
export declare const RunSchematicName = "run-schematic"; export interface RunSchematicTaskOptions<T> { collection: string | null; name: string; options: T; }
import { ModuleMetadata } from '../metadata'; export interface MetadataReaderHost { getSourceFileMetadata(filePath: string): ModuleMetadata | undefined; cacheMetadata?(fileName: string): boolean; fileExists(filePath: string): boolean; readFile(filePath: string): string; } export interface MetadataReaderCache { } export declare function createMetadataReaderCache(): MetadataReaderCache; export declare function readMetadata(filePath: string, host: MetadataReaderHost, cache?: MetadataReaderCache): ModuleMetadata[] | undefined;
export declare function arrayify<T>(arg?: T | T[]): T[]; export declare function objectify(arg: any): any; export declare function hasOwnProperty(arg: {}, key: string): boolean; export declare function camelize(stringWithHyphens: string): string; export declare function isUpperCase(str: string): boolean; export declare function isLowerCase(str: string): boolean; export declare function dedent(strings: TemplateStringsArray, ...values: any[]): string; export declare function stripComments(content: string): string; export declare function escapeRegExp(re: string): string; export declare type Equal<T> = (a: T, b: T) => boolean; export declare function arraysAreEqual<T>(a: ReadonlyArray<T> | undefined, b: ReadonlyArray<T> | undefined, eq: Equal<T>): boolean; export declare function find<T, U>(inputs: T[], getResult: (t: T) => U | undefined): U | undefined; export declare function flatMap<T, U>(inputs: ReadonlyArray<T>, getOutputs: (input: T, index: number) => ReadonlyArray<U>): U[]; export declare function mapDefined<T, U>(inputs: ReadonlyArray<T>, getOutput: (input: T) => U | undefined): U[]; export declare function readBufferWithDetectedEncoding(buffer: Buffer): string; export declare type Encoding = "utf8" | "utf8-bom" | "utf16le" | "utf16be"; export declare function detectBufferEncoding(buffer: Buffer, length?: number): Encoding; export declare function denormalizeWinPath(path: string): string; export declare function isPascalCased(name: string): boolean; export declare function isCamelCased(name: string): boolean; export declare function isKebabCased(name: string): boolean;
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static DEFAULT_ALLOWED_BLANKS: number; static metadata: Lint.IRuleMetadata; static FAILURE_STRING_FACTORY(allowed: number): string; isEnabled(): boolean; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; } export declare function getTemplateRanges(sourceFile: ts.SourceFile): ts.TextRange[];
import * as ts from 'typescript'; export declare function collectDeepNodes<T extends ts.Node>(node: ts.Node, kind: ts.SyntaxKind): T[];
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING(name: string): string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare const _default: never[]; export default _default;
import { ParseTreeResult, Parser } from './parser'; export { ParseTreeResult, TreeError } from './parser'; export declare class XmlParser extends Parser { constructor(); parse(source: string, url: string, parseExpansionForms?: boolean): ParseTreeResult; }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import * as ts from "typescript"; import * as Lint from "../index"; import { Encoding } from "../utils"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING(actual: Encoding): string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
export declare class ElementAnimationStyleHandler { private readonly _element; private readonly _name; private readonly _duration; private readonly _delay; private readonly _easing; private readonly _fillMode; private readonly _onDoneFn; private readonly _eventFn; private _finished; private _destroyed; private _startTime; private _position; constructor(_element: any, _name: string, _duration: number, _delay: number, _easing: string, _fillMode: '' | 'both' | 'forwards', _onDoneFn: () => any); apply(): void; pause(): void; resume(): void; setPosition(position: number): void; getPosition(): number; private _handleCallback; finish(): void; destroy(): void; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING_ALPHABETIZE(prevName: string, curName: string): string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import * as ts from "typescript"; import { IOptions } from "../rule/rule"; import { RuleWalker } from "./ruleWalker"; export declare abstract class ScopeAwareRuleWalker<T> extends RuleWalker { private readonly scopeStack; constructor(sourceFile: ts.SourceFile, options: IOptions); abstract createScope(node: ts.Node): T; getCurrentScope(): T; getAllScopes(): T[]; getCurrentDepth(): number; onScopeStart(): void; onScopeEnd(): void; protected visitNode(node: ts.Node): void; protected isScopeBoundary(node: ts.Node): boolean; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.TypedRule { static metadata: Lint.IRuleMetadata; applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): Lint.RuleFailure[]; }
import { Injector } from '@angular/core'; import { MonoTypeOperatorFunction } from 'rxjs'; import { NavigationTransition } from '../router'; export declare function resolveData(paramsInheritanceStrategy: 'emptyOnly' | 'always', moduleInjector: Injector): MonoTypeOperatorFunction<NavigationTransition>;
import { Route, UrlMatchResult } from './config'; import { UrlSegment, UrlSegmentGroup } from './url_tree'; export declare const PRIMARY_OUTLET = "primary"; export declare type Params = { [key: string]: any; }; export interface ParamMap { has(name: string): boolean; get(name: string): string | null; getAll(name: string): string[]; readonly keys: string[]; } export declare function convertToParamMap(params: Params): ParamMap; export declare function navigationCancelingError(message: string): Error; export declare function isNavigationCancelingError(error: Error): any; export declare function defaultUrlMatcher(segments: UrlSegment[], segmentGroup: UrlSegmentGroup, route: Route): UrlMatchResult | null;
export * from 'rxjs-compat/operator/skipLast';
import * as html from '../ml_parser/ast'; import { InterpolationConfig } from '../ml_parser/interpolation_config'; import { ParseTreeResult } from '../ml_parser/parser'; import * as i18n from './i18n_ast'; import { I18nError } from './parse_util'; import { TranslationBundle } from './translation_bundle'; export declare function extractMessages(nodes: html.Node[], interpolationConfig: InterpolationConfig, implicitTags: string[], implicitAttrs: { [k: string]: string[]; }): ExtractionResult; export declare function mergeTranslations(nodes: html.Node[], translations: TranslationBundle, interpolationConfig: InterpolationConfig, implicitTags: string[], implicitAttrs: { [k: string]: string[]; }): ParseTreeResult; export declare class ExtractionResult { messages: i18n.Message[]; errors: I18nError[]; constructor(messages: i18n.Message[], errors: I18nError[]); }
import { InjectionToken, ɵConsole as Console } from '@angular/core'; import { EventManagerPlugin } from './event_manager'; export declare const HAMMER_GESTURE_CONFIG: InjectionToken<HammerGestureConfig>; export declare type HammerLoader = () => Promise<void>; export declare const HAMMER_LOADER: InjectionToken<HammerLoader>; export interface HammerInstance { on(eventName: string, callback?: Function): void; off(eventName: string, callback?: Function): void; destroy?(): void; } export declare class HammerGestureConfig { events: string[]; overrides: { [key: string]: Object; }; options?: { cssProps?: any; domEvents?: boolean; enable?: boolean | ((manager: any) => boolean); preset?: any[]; touchAction?: string; recognizers?: any[]; inputClass?: any; inputTarget?: EventTarget; }; buildHammer(element: HTMLElement): HammerInstance; } export declare class HammerGesturesPlugin extends EventManagerPlugin { private _config; private console; private loader?; constructor(doc: any, _config: HammerGestureConfig, console: Console, loader?: HammerLoader | null | undefined); supports(eventName: string): boolean; addEventListener(element: HTMLElement, eventName: string, handler: Function): Function; isCustomEvent(eventName: string): boolean; }
import 'rxjs-compat/add/operator/delay';
import 'rxjs-compat/add/operator/catch';
export * from 'rxjs-compat/operator/concat';
import { Observable } from '../Observable'; import { SchedulerLike } from '../types'; export declare function interval(period?: number, scheduler?: SchedulerLike): Observable<number>;
import { AnimationPlayer, NoopAnimationPlayer, ɵStyleData } from '@angular/animations'; import { ɵAnimationDriver as AnimationDriver } from '@angular/animations/browser'; export declare class MockAnimationDriver implements AnimationDriver { static log: AnimationPlayer[]; validateStyleProperty(prop: string): boolean; matchesElement(element: any, selector: string): boolean; containsElement(elm1: any, elm2: any): boolean; query(element: any, selector: string, multi: boolean): any[]; computeStyle(element: any, prop: string, defaultValue?: string): string; animate(element: any, keyframes: { [key: string]: string | number; }[], duration: number, delay: number, easing: string, previousPlayers?: any[]): MockAnimationPlayer; } export declare class MockAnimationPlayer extends NoopAnimationPlayer { element: any; keyframes: { [key: string]: string | number; }[]; duration: number; delay: number; easing: string; previousPlayers: any[]; private __finished; private __started; previousStyles: { [key: string]: string | number; }; private _onInitFns; currentSnapshot: ɵStyleData; constructor(element: any, keyframes: { [key: string]: string | number; }[], duration: number, delay: number, easing: string, previousPlayers: any[]); finish(): void; destroy(): void; play(): void; hasStarted(): boolean; beforeDestroy(): void; }
import { AnimationDriver, ɵAnimationEngine as AnimationEngine, ɵAnimationStyleNormalizer as AnimationStyleNormalizer, ɵCssKeyframesDriver as CssKeyframesDriver, ɵWebAnimationsDriver as WebAnimationsDriver, ɵWebAnimationsStyleNormalizer as WebAnimationsStyleNormalizer } from '@angular/animations/browser'; import { InjectionToken, NgZone, Provider } from '@angular/core'; import { ɵDomRendererFactory2 as DomRendererFactory2 } from '@angular/platform-browser'; import { AnimationRendererFactory } from './animation_renderer'; export declare class InjectableAnimationEngine extends AnimationEngine { constructor(doc: any, driver: AnimationDriver, normalizer: AnimationStyleNormalizer); } export declare function instantiateSupportedAnimationDriver(): WebAnimationsDriver | CssKeyframesDriver; export declare function instantiateDefaultStyleNormalizer(): WebAnimationsStyleNormalizer; export declare function instantiateRendererFactory(renderer: DomRendererFactory2, engine: AnimationEngine, zone: NgZone): AnimationRendererFactory; export declare const ANIMATION_MODULE_TYPE: InjectionToken<"NoopAnimations" | "BrowserAnimations">; export declare const BROWSER_ANIMATIONS_PROVIDERS: Provider[]; export declare const BROWSER_NOOP_ANIMATIONS_PROVIDERS: Provider[];
export * from 'rxjs-compat/observable/fromPromise';
export * from 'rxjs-compat/operators/materialize';
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import { PlayerFactory, PlayerFactoryBuildFn } from '../interfaces/player'; export declare function bindPlayerFactory<T>(factoryFn: PlayerFactoryBuildFn, value: T): PlayerFactory; export declare class BoundPlayerFactory<T> { fn: PlayerFactoryBuildFn; value: T; '__brand__': 'Brand for PlayerFactory that nothing will match'; constructor(fn: PlayerFactoryBuildFn, value: T); }
import * as Lint from 'tslint'; import * as ts from 'typescript'; import { NgWalker } from './angular/ngWalker'; import { CssAst } from './angular/styles/cssAst'; import { ComponentMetadata, StyleMetadata } from './angular/metadata'; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; } export declare class UnusedCssNgVisitor extends NgWalker { private templateAst; visitClassDeclaration(declaration: ts.ClassDeclaration): void; protected visitNgStyleHelper(style: CssAst, context: ComponentMetadata, styleMetadata: StyleMetadata, baseStart: number): void; private validateStyles; }
declare const _default: ({} | undefined)[]; export default _default;
import {zoneSymbol} from './utils'; Zone.__load_patch('toString', (global: any) => { const originalFunctionToString = Function.prototype.toString; const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol('OriginalDelegate'); const PROMISE_SYMBOL = zoneSymbol('Promise'); const ERROR_SYMBOL = zoneSymbol('Error'); const newFunctionToString = function toString() { if (typeof this === 'function') { const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL]; if (originalDelegate) { if (typeof originalDelegate === 'function') { return originalFunctionToString.apply(this[ORIGINAL_DELEGATE_SYMBOL], arguments); } else { return Object.prototype.toString.call(originalDelegate); } } if (this === Promise) { const nativePromise = global[PROMISE_SYMBOL]; if (nativePromise) { return originalFunctionToString.apply(nativePromise, arguments); } } if (this === Error) { const nativeError = global[ERROR_SYMBOL]; if (nativeError) { return originalFunctionToString.apply(nativeError, arguments); } } } return originalFunctionToString.apply(this, arguments); }; (newFunctionToString as any)[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString; Function.prototype.toString = newFunctionToString; const originalObjectToString = Object.prototype.toString; const PROMISE_OBJECT_TO_STRING = '[object Promise]'; Object.prototype.toString = function() { if (this instanceof Promise) { return PROMISE_OBJECT_TO_STRING; } return originalObjectToString.apply(this, arguments); }; });
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BAM': string[]; 'GEL': (string | undefined)[]; 'KRW': (string | undefined)[]; 'NZD': (string | undefined)[]; 'TWD': string[]; 'USD': string[]; 'VND': (string | undefined)[]; } | undefined)[]; export default _default;
export declare const JSONP_HOME = "__ng_jsonp__"; export declare class BrowserJsonp { build(url: string): any; nextRequestID(): string; requestCallback(id: string): string; exposeConnection(id: string, connection: any): void; removeConnection(id: string): void; send(node: any): void; cleanup(node: any): void; }
export * from 'rxjs-compat/operator/timestamp';
import { OperatorFunction, MonoTypeOperatorFunction } from '../types'; export declare function scan<T>(accumulator: (acc: T, value: T, index: number) => T, seed?: T): MonoTypeOperatorFunction<T>; export declare function scan<T>(accumulator: (acc: T[], value: T, index: number) => T[], seed?: T[]): OperatorFunction<T, T[]>; export declare function scan<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed?: R): OperatorFunction<T, R>;
import { iterator as Symbol_iterator } from '../symbol/iterator'; export function isIterable(input: any): input is Iterable<any> { return input && typeof input[Symbol_iterator] === 'function'; }
export * from 'rxjs-compat/util/identity';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; 'ZAR': string[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'GBP': string[]; 'JPY': string[]; 'SSP': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/util/subscribeTo';
import 'rxjs-compat/add/observable/concat';
export * from 'rxjs-compat/operator/single';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ANG': string[]; 'AUD': string[]; 'CAD': string[]; 'FJD': string[]; 'JPY': string[]; 'SBD': string[]; 'THB': string[]; 'TWD': string[]; 'USD': string[]; 'XPF': never[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export { createLanguageService } from './src/language_service'; export * from './src/ts_plugin'; export { Completion, Completions, Declaration, Declarations, Definition, Diagnostic, Diagnostics, Hover, HoverTextSection, LanguageService, LanguageServiceHost, Location, Span, TemplateSource, TemplateSources } from './src/types'; export { TypeScriptServiceHost, createLanguageServiceFromTypescript } from './src/typescript_host'; export { VERSION } from './src/version';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': string[]; 'CNY': string[]; 'JPY': string[]; 'KRW': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { CompileReflector } from './compile_reflector'; export declare enum LifecycleHooks { OnInit = 0, OnDestroy = 1, DoCheck = 2, OnChanges = 3, AfterContentInit = 4, AfterContentChecked = 5, AfterViewInit = 6, AfterViewChecked = 7 } export declare const LIFECYCLE_HOOKS_VALUES: LifecycleHooks[]; export declare function hasLifecycleHook(reflector: CompileReflector, hook: LifecycleHooks, token: any): boolean; export declare function getAllLifecycleHooks(reflector: CompileReflector, token: any): LifecycleHooks[];
declare function treeKill( pid: number, signal?: string | number, callback?: (error?: Error) => void, ): void; declare namespace treeKill {} export = treeKill;
import 'rxjs-compat/add/operator/max';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NOK': string[]; 'NZD': (string | undefined)[]; 'RON': (string | undefined)[]; 'TWD': (string | undefined)[]; 'USD': (string | undefined)[]; 'VND': (string | undefined)[]; 'XAF': never[]; 'XCD': (string | undefined)[]; 'XPF': never[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import { MonoTypeOperatorFunction } from '../types'; export declare function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import * as Lint from 'tslint'; import * as ts from 'typescript'; import { NgWalker } from './angular/ngWalker'; export declare class Rule extends Lint.Rules.AbstractRule { static readonly metadata: Lint.IRuleMetadata; static FAILURE_WITHOUT_PREFIX: string; static FAILURE_WITH_PREFIX: string; prefix: string; hasPrefix: boolean; private prefixChecker; private validator; constructor(options: Lint.IOptions); apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; isEnabled(): boolean; validateName(name: string): boolean; validatePrefix(prefix: string): boolean; } export declare class ClassMetadataWalker extends NgWalker { private rule; constructor(sourceFile: ts.SourceFile, rule: Rule); protected visitNgPipe(controller: ts.ClassDeclaration, decorator: ts.Decorator): void; private validateProperties; private validateProperty; private getFailureMessage; }
export * from 'rxjs-compat/operators/timeoutWith';
import { CompileInjectableMetadata } from './compile_metadata'; import { CompileReflector } from './compile_reflector'; import * as o from './output/output_ast'; import { OutputContext } from './util'; export declare class InjectableCompiler { private reflector; private alwaysGenerateDef; private tokenInjector; constructor(reflector: CompileReflector, alwaysGenerateDef: boolean); private depsArray; factoryFor(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression; injectableDef(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression; compile(injectable: CompileInjectableMetadata, ctx: OutputContext): void; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'KES': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import 'rxjs-compat/add/operator/elementAt';
import { DisplayProcessor } from "./display-processor"; export declare class Configuration { suite?: { displayNumber?: boolean; }; spec?: { displayErrorMessages?: boolean; displayStacktrace?: boolean; displaySuccessful?: boolean; displayFailed?: boolean; displayPending?: boolean; displayDuration?: boolean; }; summary?: { displayErrorMessages?: boolean; displayStacktrace?: boolean; displaySuccessful?: boolean; displayFailed?: boolean; displayPending?: boolean; displayDuration?: boolean; }; colors?: { enabled?: boolean; successful?: string; failed?: string; pending?: string; }; prefixes?: { successful?: string; failed?: string; pending?: string; }; stacktrace?: { filter?(stacktrace: string): string; }; customProcessors?: Array<typeof DisplayProcessor>; customOptions?: any; print?: (log: string) => void; }
export * from 'rxjs-compat/scheduler/async';
import { compileComponent, compileDirective } from '../../render3/jit/directive'; import { compileInjectable } from '../../render3/jit/injectable'; import { compileNgModule, compileNgModuleDefs, patchComponentDefWithScope } from '../../render3/jit/module'; import { compilePipe } from '../../render3/jit/pipe'; export declare const ivyEnabled = true; export declare const R3_COMPILE_COMPONENT: typeof compileComponent; export declare const R3_COMPILE_DIRECTIVE: typeof compileDirective; export declare const R3_COMPILE_INJECTABLE: typeof compileInjectable; export declare const R3_COMPILE_NGMODULE: typeof compileNgModule; export declare const R3_COMPILE_PIPE: typeof compilePipe; export declare const R3_COMPILE_NGMODULE_DEFS: typeof compileNgModuleDefs; export declare const R3_PATCH_COMPONENT_DEF_WTIH_SCOPE: typeof patchComponentDefWithScope;
import { StaticSymbolResolverHost } from '@angular/compiler'; import { CompilerOptions } from '@angular/compiler-cli/src/language_services'; import * as ts from 'typescript'; export declare class ReflectorHost implements StaticSymbolResolverHost { private options; private moduleResolutionCache; private hostAdapter; private metadataReaderCache; constructor(getProgram: () => ts.Program, serviceHost: ts.LanguageServiceHost, options: CompilerOptions); getMetadataFor(modulePath: string): { [key: string]: any; }[] | undefined; moduleNameToFileName(moduleName: string, containingFile?: string): string | null; getOutputName(filePath: string): string; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'CNY': string[]; 'ILP': string[]; 'THB': string[]; 'TWD': string[]; } | undefined)[]; export default _default;
import { Observable } from '../Observable'; import { isArray } from '../util/isArray'; import { MonoTypeOperatorFunction, OperatorFunction } from '../types'; import { race as raceStatic } from '../observable/race'; export function race<T>(observables: Array<Observable<T>>): MonoTypeOperatorFunction<T>; export function race<T, R>(observables: Array<Observable<T>>): OperatorFunction<T, R>; export function race<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): MonoTypeOperatorFunction<T>; export function race<T, R>(...observables: Array<Observable<any> | Array<Observable<any>>>): OperatorFunction<T, R>; export function race<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): MonoTypeOperatorFunction<T> { return function raceOperatorFunction(source: Observable<T>) { if (observables.length === 1 && isArray(observables[0])) { observables = <Array<Observable<T>>>observables[0]; } return source.lift.call(raceStatic<T>(source, ...observables)); }; }
import { InjectionToken } from '@angular/core'; export interface ControlValueAccessor { writeValue(obj: any): void; registerOnChange(fn: any): void; registerOnTouched(fn: any): void; setDisabledState?(isDisabled: boolean): void; } export declare const NG_VALUE_ACCESSOR: InjectionToken<ControlValueAccessor>;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'BAM': string[]; 'CZK': string[]; 'PLN': string[]; 'RSD': string[]; 'TRY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export * from './public_api';
export * from 'rxjs-compat/operator/window';
export * from 'rxjs-compat/observable/ArrayObservable';
export interface Schema { flat?: boolean; lintFix?: boolean; name: string; path?: string; project?: string; spec?: boolean; }
import { SourceMap } from '@angular/compiler'; export interface SourceLocation { line: number; column: number; source: string; } export declare function originalPositionFor(sourceMap: SourceMap, genPosition: { line: number | null; column: number | null; }): SourceLocation; export declare function extractSourceMap(source: string): SourceMap | null;
export * from './android_sdk'; export * from './appium'; export * from './binary'; export * from './chrome_driver'; export * from './gecko_driver'; export * from './iedriver'; export * from './standalone';
import 'rxjs-compat/add/operator/last';
export declare const ExpTypes: { Binary(ast: any): boolean; Quote(ast: any): boolean; EmptyExpr(ast: any): boolean; ImplicitReceiver(ast: any): boolean; Chain(ast: any): boolean; Conditional(ast: any): boolean; PropertyRead(ast: any): boolean; PropertyWrite(ast: any): boolean; SafePropertyRead(ast: any): boolean; KeyedRead(ast: any): boolean; KeyedWrite(ast: any): boolean; BindingPipe(ast: any): boolean; LiteralPrimitive(ast: any): boolean; LiteralArray(ast: any): boolean; LiteralMap(ast: any): boolean; Interpolation(ast: any): boolean; PrefixNot(ast: any): boolean; MethodCall(ast: any): boolean; SafeMethodCall(ast: any): boolean; FunctionCall(ast: any): boolean; ASTWithSource(ast: any): boolean; };
import { Observable } from '../Observable'; import { SchedulerLike } from '../types'; import { Subscription } from '../Subscription'; import { iterator as Symbol_iterator } from '../symbol/iterator'; import { subscribeToIterable } from '../util/subscribeToIterable'; export function fromIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) { if (!input) { throw new Error('Iterable cannot be null'); } if (!scheduler) { return new Observable<T>(subscribeToIterable(input)); } else { return new Observable<T>(subscriber => { const sub = new Subscription(); let iterator: Iterator<T>; sub.add(() => { if (iterator && typeof iterator.return === 'function') { iterator.return(); } }); sub.add(scheduler.schedule(() => { iterator = input[Symbol_iterator](); sub.add(scheduler.schedule(function () { if (subscriber.closed) { return; } let value: T; let done: boolean; try { const result = iterator.next(); value = result.value; done = result.done; } catch (err) { subscriber.error(err); return; } if (done) { subscriber.complete(); } else { subscriber.next(value); this.schedule(); } })); })); return sub; }); } }
import { Type } from '../type'; export interface TypeDecorator { <T extends Type<any>>(type: T): T; (target: Object, propertyKey?: string | symbol, parameterIndex?: number): void; } export declare const ANNOTATIONS = "__annotations__"; export declare const PARAMETERS = "__parameters__"; export declare const PROP_METADATA = "__prop__metadata__"; export declare function makeDecorator<T>(name: string, props?: (...args: any[]) => any, parentClass?: any, additionalProcessing?: (type: Type<T>) => void, typeFn?: (type: Type<T>, ...args: any[]) => void): { new (...args: any[]): any; (...args: any[]): any; (...args: any[]): (cls: any) => any; }; export declare function makeParamDecorator(name: string, props?: (...args: any[]) => any, parentClass?: any): any; export declare function makePropDecorator(name: string, props?: (...args: any[]) => any, parentClass?: any, additionalProcessing?: (target: any, name: string, ...args: any[]) => void): any;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number' && typeof x !== 'function');
import { ConstantPool, R3DirectiveMetadata, R3QueryMetadata } from '@angular/compiler'; import * as ts from 'typescript'; import { ClassMember, Decorator, ReflectionHost } from '../../host'; import { AnalysisOutput, CompileResult, DecoratorHandler } from '../../transform'; import { SelectorScopeRegistry } from './selector_scope'; export declare class DirectiveDecoratorHandler implements DecoratorHandler<R3DirectiveMetadata, Decorator> { private checker; private reflector; private scopeRegistry; private isCore; constructor(checker: ts.TypeChecker, reflector: ReflectionHost, scopeRegistry: SelectorScopeRegistry, isCore: boolean); detect(node: ts.Declaration, decorators: Decorator[] | null): Decorator | undefined; analyze(node: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<R3DirectiveMetadata>; compile(node: ts.ClassDeclaration, analysis: R3DirectiveMetadata, pool: ConstantPool): CompileResult; } export declare function extractDirectiveMetadata(clazz: ts.ClassDeclaration, decorator: Decorator, checker: ts.TypeChecker, reflector: ReflectionHost, isCore: boolean): { decorator: Map<string, ts.Expression>; metadata: R3DirectiveMetadata; decoratedElements: ClassMember[]; } | undefined; export declare function extractQueryMetadata(exprNode: ts.Node, name: string, args: ReadonlyArray<ts.Expression>, propertyName: string, reflector: ReflectionHost, checker: ts.TypeChecker): R3QueryMetadata; export declare function extractQueriesFromDecorator(queryData: ts.Expression, reflector: ReflectionHost, checker: ts.TypeChecker, isCore: boolean): { content: R3QueryMetadata[]; view: R3QueryMetadata[]; }; export declare function parseFieldArrayValue(directive: Map<string, ts.Expression>, field: string, reflector: ReflectionHost, checker: ts.TypeChecker): null | string[]; export declare function queriesFromFields(fields: { member: ClassMember; decorators: Decorator[]; }[], reflector: ReflectionHost, checker: ts.TypeChecker): R3QueryMetadata[];
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AED': string[]; 'ARS': (string | undefined)[]; 'AUD': string[]; 'BBD': (string | undefined)[]; 'BHD': string[]; 'BMD': (string | undefined)[]; 'BND': (string | undefined)[]; 'BSD': (string | undefined)[]; 'BZD': (string | undefined)[]; 'CAD': string[]; 'CLP': (string | undefined)[]; 'CNY': string[]; 'COP': (string | undefined)[]; 'CUP': (string | undefined)[]; 'DOP': (string | undefined)[]; 'DZD': string[]; 'EGP': string[]; 'FJD': (string | undefined)[]; 'GBP': string[]; 'GYD': (string | undefined)[]; 'HKD': string[]; 'IQD': string[]; 'IRR': string[]; 'JMD': (string | undefined)[]; 'JOD': string[]; 'JPY': string[]; 'KWD': string[]; 'KYD': (string | undefined)[]; 'LBP': string[]; 'LYD': string[]; 'MAD': string[]; 'MRO': string[]; 'MXN': string[]; 'NZD': string[]; 'OMR': string[]; 'QAR': string[]; 'SAR': string[]; 'SBD': (string | undefined)[]; 'SDD': string[]; 'SDG': string[]; 'SRD': (string | undefined)[]; 'SYP': string[]; 'THB': string[]; 'TND': string[]; 'TTD': (string | undefined)[]; 'TWD': string[]; 'USD': string[]; 'UYU': (string | undefined)[]; 'XXX': string[]; 'YER': string[]; } | undefined)[]; export default _default;
import { Component, OnInit<% if(!!viewEncapsulation) { %>, ViewEncapsulation<% }%><% if(changeDetection !== 'Default') { %>, ChangeDetectionStrategy<% }%> } from '@angular/core'; @Component({ selector: '<%= selector %>',<% if(inlineTemplate) { %> template: ` <p> <%= dasherize(name) %> works! </p> `,<% } else { %> templateUrl: './<%= dasherize(name) %>.component.html',<% } if(inlineStyle) { %> styles: []<% } else { %> styleUrls: ['./<%= dasherize(name) %>.component.<%= styleext %>']<% } %><% if(!!viewEncapsulation) { %>, encapsulation: ViewEncapsulation.<%= viewEncapsulation %><% } if (changeDetection !== 'Default') { %>, changeDetection: ChangeDetectionStrategy.<%= changeDetection %><% } %> }) export class <%= classify(name) %>Component implements OnInit { constructor() { } ngOnInit() { } }
import * as stream from 'stream'; import { WebDriverCommand } from './webdriver_commands'; export declare class WebDriverLogger { logStream: stream.Writable; readonly logName: string; constructor(); setLogDir(logDir: string): void; logWebDriverCommand(command: WebDriverCommand): void; logEvent(msg: string, sessionId: string, elapsedMs: number): void; private renderData(command); private renderResponse(command); private timestamp(); }
export * from './mock_backend';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/operator/groupBy';
export * from 'rxjs-compat/operator/materialize';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare module 'https-proxy-agent' { import * as https from 'https'; namespace HttpsProxyAgent { interface HttpsProxyAgentOptions { host: string; port: number | string; secureProxy?: boolean; headers?: { [key: string]: string; }; [key: string]: any; } } class HttpsProxyAgent extends https.Agent { constructor(opts: HttpsProxyAgent.HttpsProxyAgentOptions | string); } export = HttpsProxyAgent; }
import { Operator } from '../Operator'; import { Subscriber } from '../Subscriber'; import { Observable } from '../Observable'; import { OuterSubscriber } from '../OuterSubscriber'; import { InnerSubscriber } from '../InnerSubscriber'; import { subscribeToResult } from '../util/subscribeToResult'; import { MonoTypeOperatorFunction, TeardownLogic, ObservableInput } from '../types'; import { Subscription } from '../Subscription'; export function skipUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> { return (source: Observable<T>) => source.lift(new SkipUntilOperator(notifier)); } class SkipUntilOperator<T> implements Operator<T, T> { constructor(private notifier: Observable<any>) { } call(destination: Subscriber<T>, source: any): TeardownLogic { return source.subscribe(new SkipUntilSubscriber(destination, this.notifier)); } } class SkipUntilSubscriber<T, R> extends OuterSubscriber<T, R> { private hasValue: boolean = false; private innerSubscription: Subscription; constructor(destination: Subscriber<R>, notifier: ObservableInput<any>) { super(destination); const innerSubscriber = new InnerSubscriber(this, undefined, undefined); this.add(innerSubscriber); this.innerSubscription = innerSubscriber; subscribeToResult(this, notifier, undefined, undefined, innerSubscriber); } protected _next(value: T) { if (this.hasValue) { super._next(value); } } notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void { this.hasValue = true; if (this.innerSubscription) { this.innerSubscription.unsubscribe(); } } notifyComplete() { } }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export declare function resetFakeAsyncZone(): void; export declare function fakeAsync(fn: Function): (...args: any[]) => any; export declare function tick(millis?: number): void; export declare function flush(maxTurns?: number): number; export declare function discardPeriodicTasks(): void; export declare function flushMicrotasks(): void;
import 'symbol-observable';
export * from 'rxjs-compat/operators/debounceTime';
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare const _global: { [name: string]: any; }; export { _global as global }; export declare function getSymbolIterator(): string | symbol; export declare function scheduleMicroTask(fn: Function): void; export declare function looseIdentical(a: any, b: any): boolean; export declare function stringify(token: any): string; export declare function noSideEffects(fn: () => void): string;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'KES': string[]; 'TZS': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import {bindArguments, patchMethod, patchOnProperties, setShouldCopySymbolProperties} from '../common/utils'; Zone.__load_patch('node_util', (global: any, Zone: ZoneType, api: _ZonePrivate) => { api.patchOnProperties = patchOnProperties; api.patchMethod = patchMethod; api.bindArguments = bindArguments; setShouldCopySymbolProperties(true); });
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ETB': string[]; 'JPY': string[]; 'KES': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/util/root';
declare const _default: ((string[] | undefined)[] | undefined)[]; export default _default;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': string[]; 'BDT': (string | undefined)[]; 'BOB': (string | undefined)[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': (string | undefined)[]; 'CUP': (string | undefined)[]; 'EGP': (string | undefined)[]; 'EUR': (string | undefined)[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'ILS': (string | undefined)[]; 'INR': (string | undefined)[]; 'ISK': (string | undefined)[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'MXN': (string | undefined)[]; 'NZD': (string | undefined)[]; 'PYG': (string | undefined)[]; 'SCR': string[]; 'SEK': (string | undefined)[]; 'TWD': (string | undefined)[]; 'USD': (string | undefined)[]; 'UYU': (string | undefined)[]; 'VND': (string | undefined)[]; 'XAF': never[]; 'XCD': (string | undefined)[]; 'XOF': never[]; 'XPF': string[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/operators/min';
declare const _default: (string[][] | undefined)[]; export default _default;
export { anchorDef, elementDef } from './element'; export { clearOverrides, createNgModuleFactory, overrideComponentView, overrideProvider } from './entrypoint'; export { ngContentDef } from './ng_content'; export { moduleDef, moduleProvideDef } from './ng_module'; export { directiveDef, pipeDef, providerDef } from './provider'; export { pureArrayDef, pureObjectDef, purePipeDef } from './pure_expression'; export { queryDef } from './query'; export { ViewRef_, createComponentFactory, getComponentViewDefinitionFactory, nodeValue } from './refs'; export { initServicesIfNeeded } from './services'; export { textDef } from './text'; export { EMPTY_ARRAY, EMPTY_MAP, createRendererType2, elementEventFullName, inlineInterpolate, interpolate, rootRenderNodes, tokenKey, unwrapValue } from './util'; export { viewDef } from './view'; export { attachEmbeddedView, detachEmbeddedView, moveEmbeddedView } from './view_attach'; export * from './types';
import { NgModule, NgModuleTransitiveScopes } from '../../metadata/ng_module'; import { Type } from '../../type'; import { ComponentDef } from '../interfaces/definition'; export declare function compileNgModule(moduleType: Type<any>, ngModule: NgModule): void; export declare function compileNgModuleDefs(moduleType: Type<any>, ngModule: NgModule): void; export declare function patchComponentDefWithScope<C>(componentDef: ComponentDef<C>, transitiveScopes: NgModuleTransitiveScopes): void; export declare function transitiveScopesFor<T>(moduleType: Type<T>): NgModuleTransitiveScopes;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'LRD': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare function setPrototypeOf(o: any, proto: object | null): any; export = setPrototypeOf;
import * as q from 'q'; import { Config } from '../config'; import { DriverProvider } from './driverProvider'; export declare class Sauce extends DriverProvider { sauceServer_: any; constructor(config: Config); updateJob(update: any): q.Promise<any>; protected setupDriverEnv(): q.Promise<any>; private getSauceEndpoint(region); }
import { Operator } from '../Operator'; import { Subscriber } from '../Subscriber'; import { Observable } from '../Observable'; import { SubscribeOnObservable } from '../observable/SubscribeOnObservable'; import { MonoTypeOperatorFunction, SchedulerLike, TeardownLogic } from '../types'; export function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> { return function subscribeOnOperatorFunction(source: Observable<T>): Observable<T> { return source.lift(new SubscribeOnOperator<T>(scheduler, delay)); }; } class SubscribeOnOperator<T> implements Operator<T, T> { constructor(private scheduler: SchedulerLike, private delay: number) { } call(subscriber: Subscriber<T>, source: any): TeardownLogic { return new SubscribeOnObservable<T>( source, this.delay, this.scheduler ).subscribe(subscriber); } }
export * from './collector'; export * from './schema'; export * from './bundle_index_host';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { PipeTransform } from '@angular/core'; export declare class I18nSelectPipe implements PipeTransform { transform(value: string | null | undefined, mapping: { [key: string]: string; }): string; }
export * from 'rxjs-compat/operator/min';
export * from 'rxjs-compat/observable/combineLatest';
import { IRuleMetadata, RuleFailure, Rules, RuleWalker } from 'tslint/lib'; import { ClassDeclaration, SourceFile } from 'typescript/lib/typescript'; export declare class Rule extends Rules.AbstractRule { static readonly metadata: IRuleMetadata; static readonly FAILURE_STRING: string; static readonly PIPE_INTERFACE_NAME: string; apply(sourceFile: SourceFile): RuleFailure[]; } export declare class ClassMetadataWalker extends RuleWalker { visitClassDeclaration(node: ClassDeclaration): void; private validateClassDeclaration; }
export * from './src/platform-browser-dynamic';
import 'rxjs-compat/add/operator/count';
export * from './downloaded_binary'; export * from './downloader'; export * from './file_manager';
import { Immediate } from '../util/Immediate'; import { AsyncAction } from './AsyncAction'; import { AsapScheduler } from './AsapScheduler'; import { SchedulerAction } from '../types'; export class AsapAction<T> extends AsyncAction<T> { constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) { super(scheduler, work); } protected requestAsyncId(scheduler: AsapScheduler, id?: any, delay: number = 0): any { if (delay !== null && delay > 0) { return super.requestAsyncId(scheduler, id, delay); } scheduler.actions.push(this); return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate( scheduler.flush.bind(scheduler, null) )); } protected recycleAsyncId(scheduler: AsapScheduler, id?: any, delay: number = 0): any { if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) { return super.recycleAsyncId(scheduler, id, delay); } if (scheduler.actions.length === 0) { Immediate.clearImmediate(id); scheduler.scheduled = undefined; } return undefined; } }
export * from 'rxjs-compat/operators/audit';
import { DebugContext } from './types'; export declare function expressionChangedAfterItHasBeenCheckedError(context: DebugContext, oldValue: any, currValue: any, isFirstCheck: boolean): Error; export declare function viewWrappedDebugError(err: any, context: DebugContext): Error; export declare function viewDebugError(msg: string, context: DebugContext): Error; export declare function isViewDebugError(err: Error): boolean; export declare function viewDestroyedError(action: string): Error;
declare const _default: never[]; export default _default;
declare const _default: never[]; export default _default;
import { FormControl, FormGroup } from '../model'; import { AbstractFormGroupDirective } from './abstract_form_group_directive'; import { NgControl } from './ng_control'; export interface Form { addControl(dir: NgControl): void; removeControl(dir: NgControl): void; getControl(dir: NgControl): FormControl; addFormGroup(dir: AbstractFormGroupDirective): void; removeFormGroup(dir: AbstractFormGroupDirective): void; getFormGroup(dir: AbstractFormGroupDirective): FormGroup; updateModel(dir: NgControl, value: any): void; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ATS': string[]; 'AUD': string[]; 'BGM': string[]; 'BGO': string[]; 'CUC': (string | undefined)[]; 'DEM': string[]; 'FKP': (string | undefined)[]; 'GNF': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LUF': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SYP': never[]; 'THB': string[]; 'TWD': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export declare class HttpHeaders { private headers; private normalizedNames; private lazyInit; private lazyUpdate; constructor(headers?: string | { [name: string]: string | string[]; }); has(name: string): boolean; get(name: string): string | null; keys(): string[]; getAll(name: string): string[] | null; append(name: string, value: string | string[]): HttpHeaders; set(name: string, value: string | string[]): HttpHeaders; delete(name: string, value?: string | string[]): HttpHeaders; private maybeSetNormalizedName; private init; private copyFrom; private clone; private applyUpdate; }
export * from 'rxjs-compat/observable/IteratorObservable';
export * from 'rxjs-compat/interfaces';
import * as o from './output/output_ast'; import { I18nMeta } from './render3/view/i18n'; import { OutputContext } from './util'; export declare const enum DefinitionKind { Injector = 0, Directive = 1, Component = 2, Pipe = 3 } export declare class ConstantPool { statements: o.Statement[]; private translations; private deferredTranslations; private literals; private literalFactories; private injectorDefinitions; private directiveDefinitions; private componentDefinitions; private pipeDefinitions; private nextNameIndex; getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression; getDeferredTranslationConst(suffix: string): o.ReadVarExpr; setDeferredTranslationConst(variable: o.ReadVarExpr, message: string): void; getTranslationDeclStmt(variable: o.ReadVarExpr, message: string): o.DeclareVarStmt; appendTranslationMeta(meta: string | I18nMeta): void; getTranslation(message: string, meta: string, suffix: string): o.Expression; getDefinition(type: any, kind: DefinitionKind, ctx: OutputContext, forceShared?: boolean): o.Expression; getLiteralFactory(literal: o.LiteralArrayExpr | o.LiteralMapExpr): { literalFactory: o.Expression; literalFactoryArguments: o.Expression[]; }; private _getLiteralFactory; uniqueName(prefix: string): string; private definitionsOf; propertyNameOf(kind: DefinitionKind): string; private freshName; private freshTranslationName; private keyOf; }
import { Program } from '../cli'; export declare let program: Program;
import 'rxjs-compat/add/operator/exhaustMap';
import { Observable } from '../Observable'; import { SchedulerAction, SchedulerLike } from '../types'; import { async } from '../scheduler/async'; import { isNumeric } from '../util/isNumeric'; import { isScheduler } from '../util/isScheduler'; import { Subscriber } from '../Subscriber'; export function timer(dueTime: number | Date = 0, periodOrScheduler?: number | SchedulerLike, scheduler?: SchedulerLike): Observable<number> { let period = -1; if (isNumeric(periodOrScheduler)) { period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler); } else if (isScheduler(periodOrScheduler)) { scheduler = periodOrScheduler as any; } if (!isScheduler(scheduler)) { scheduler = async; } return new Observable(subscriber => { const due = isNumeric(dueTime) ? (dueTime as number) : (+dueTime - scheduler.now()); return scheduler.schedule(dispatch, due, { index: 0, period, subscriber }); }); } interface TimerState { index: number; period: number; subscriber: Subscriber<number>; } function dispatch(this: SchedulerAction<TimerState>, state: TimerState) { const { index, period, subscriber } = state; subscriber.next(index); if (subscriber.closed) { return; } else if (period === -1) { return subscriber.complete(); } state.index = index + 1; this.schedule(state, period); }
import { Type } from '../type'; export interface ValueSansProvider { useValue: any; } export interface ValueProvider extends ValueSansProvider { provide: any; multi?: boolean; } export interface StaticClassSansProvider { useClass: Type<any>; deps: any[]; } export interface StaticClassProvider extends StaticClassSansProvider { provide: any; multi?: boolean; } export interface ConstructorSansProvider { deps?: any[]; } export interface ConstructorProvider extends ConstructorSansProvider { provide: Type<any>; multi?: boolean; } export interface ExistingSansProvider { useExisting: any; } export interface ExistingProvider extends ExistingSansProvider { provide: any; multi?: boolean; } export interface FactorySansProvider { useFactory: Function; deps?: any[]; } export interface FactoryProvider extends FactorySansProvider { provide: any; multi?: boolean; } export declare type StaticProvider = ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider | any[]; export interface TypeProvider extends Type<any> { } export interface ClassSansProvider { useClass: Type<any>; } export interface ClassProvider extends ClassSansProvider { provide: any; multi?: boolean; } export declare type Provider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider | any[];
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'KES': string[]; 'UGX': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/operator/onErrorResumeNext';
export * from 'rxjs-compat/observable/fromIterable';
import { InjectionToken } from '@angular/core'; export declare const DOCUMENT: InjectionToken<Document>;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
export declare class TemplateDrivenErrors { static modelParentException(): void; static formGroupNameException(): void; static missingNameException(): void; static modelGroupParentException(): void; static ngFormWarning(): void; }
import { mergeAll } from './mergeAll'; import { OperatorFunction, ObservableInput } from '../types'; export function concatAll<T>(): OperatorFunction<ObservableInput<T>, T>; export function concatAll<R>(): OperatorFunction<any, R>; export function concatAll<T>(): OperatorFunction<ObservableInput<T>, T> { return mergeAll<T>(1); }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'GBP': string[]; 'JPY': string[]; 'SSP': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export * from './ivy_switch_on';
import { BaseException } from '@angular-devkit/core'; import { Arguments, Option } from './interface'; export declare class ParseArgumentException extends BaseException { readonly comments: string[]; readonly parsed: Arguments; readonly ignored: string[]; constructor(comments: string[], parsed: Arguments, ignored: string[]); } export declare function parseFreeFormArguments(args: string[]): Arguments; export declare function parseArguments(args: string[], options: Option[] | null): Arguments;
export * from 'rxjs-compat/symbol/rxSubscriber';
export = isExtendable; declare function isExtendable(val: any): boolean; declare namespace isExtendable {}
import 'rxjs-compat/add/operator/exhaust';
import { CustomReporterResult } from "../../custom-reporter-result"; import { DisplayProcessor } from "../display-processor"; export declare class SpecPrefixesProcessor extends DisplayProcessor { displaySuccessfulSpec(spec: CustomReporterResult, log: String): String; displayFailedSpec(spec: CustomReporterResult, log: String): String; displayPendingSpec(spec: CustomReporterResult, log: String): String; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { CompileReflector } from './compile_reflector'; import { NgModule, Type } from './core'; export declare class NgModuleResolver { private _reflector; constructor(_reflector: CompileReflector); isNgModule(type: any): boolean; resolve(type: Type, throwIfNotFound?: boolean): NgModule | null; }
export * from 'rxjs-compat/observable/merge';
export * from 'rxjs-compat/operator/delay';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
export declare const NUMBER_FORMAT_REGEXP: RegExp; export declare function formatCurrency(value: number, locale: string, currency: string, currencyCode?: string, digitsInfo?: string): string; export declare function formatPercent(value: number, locale: string, digitsInfo?: string): string; export declare function formatNumber(value: number, locale: string, digitsInfo?: string): string; export declare function parseIntAutoRadix(text: string): number;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ATS': string[]; 'AUD': string[]; 'THB': string[]; 'TWD': string[]; })[]; export default _default;
export * from './src/api'; export { TypeCheckContext } from './src/context'; export { TypeCheckProgramHost } from './src/host';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'UGX': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { Observable } from '../Observable'; import { ObservableInput } from '../types'; import { subscribeToArray } from './subscribeToArray'; import { subscribeToPromise } from './subscribeToPromise'; import { subscribeToIterable } from './subscribeToIterable'; import { subscribeToObservable } from './subscribeToObservable'; import { isArrayLike } from './isArrayLike'; import { isPromise } from './isPromise'; import { isObject } from './isObject'; import { iterator as Symbol_iterator } from '../symbol/iterator'; import { observable as Symbol_observable } from '../symbol/observable'; import { Subscriber } from '../Subscriber'; export const subscribeTo = <T>(result: ObservableInput<T>) => { if (result instanceof Observable) { return (subscriber: Subscriber<T>) => { if (result._isScalar) { subscriber.next((result as any).value); subscriber.complete(); return undefined; } else { return result.subscribe(subscriber); } }; } else if (result && typeof result[Symbol_observable] === 'function') { return subscribeToObservable(result as any); } else if (isArrayLike(result)) { return subscribeToArray(result); } else if (isPromise(result)) { return subscribeToPromise(result as Promise<any>); } else if (result && typeof result[Symbol_iterator] === 'function') { return subscribeToIterable(result as any); } else { const value = isObject(result) ? 'an invalid object' : `'${result}'`; const msg = `You provided ${value} where a stream was expected.` + ' You can provide an Observable, Promise, Array, or Iterable.'; throw new TypeError(msg); } };
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'GEL': (string | undefined)[]; 'KGS': string[]; 'RON': (string | undefined)[]; 'RUB': string[]; 'RUR': string[]; 'THB': string[]; 'TMT': string[]; 'TWD': string[]; 'UAH': string[]; 'XXX': string[]; } | undefined)[]; export default _default;
import { DebugContext } from './view'; export declare const ERROR_TYPE = "ngType"; export declare const ERROR_DEBUG_CONTEXT = "ngDebugContext"; export declare const ERROR_ORIGINAL_ERROR = "ngOriginalError"; export declare const ERROR_LOGGER = "ngErrorLogger"; export declare function getType(error: Error): Function; export declare function getDebugContext(error: Error): DebugContext; export declare function getOriginalError(error: Error): Error; export declare function getErrorLogger(error: Error): (console: Console, ...values: any[]) => void;
export declare enum LogLevel { ERROR = 0, WARN = 1, INFO = 2, DEBUG = 3, } export declare enum WriteTo { CONSOLE = 0, FILE = 1, BOTH = 2, NONE = 3, } export declare class Logger { private id; static logLevel: LogLevel; static showTimestamp: boolean; static showId: boolean; static writeTo: WriteTo; static fd: any; static firstWrite: boolean; static setWrite(writeTo: WriteTo, opt_logFile?: string): void; constructor(id: string); info(...msgs: any[]): void; debug(...msgs: any[]): void; warn(...msgs: any[]): void; error(...msgs: any[]): void; log_(logLevel: LogLevel, msgs: any[]): void; print_(logLevel: LogLevel, msgs: any[]): void; static timestamp_(writeTo: WriteTo): string; static id_(logLevel: LogLevel, id: string, writeTo: WriteTo): string; static level_(logLevel: LogLevel, id: string, writeTo: WriteTo): string; static msgToFile_(msgs: any[]): string; }
import 'rxjs-compat/add/operator/debounceTime';
export {};
import * as ts from 'typescript'; export interface MetadataUrls { templateUrl: string; styleUrls: string[]; } export declare abstract class AbstractResolver { abstract resolve(decorator: ts.Decorator): MetadataUrls | null; protected getTemplateUrl(decorator: ts.Decorator): string | undefined; protected getStyleUrls(decorator: ts.Decorator): string[]; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'LUF': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
import { LocationStrategy } from '@angular/common'; export declare class MockLocationStrategy extends LocationStrategy { internalBaseHref: string; internalPath: string; internalTitle: string; urlChanges: string[]; constructor(); simulatePopState(url: string): void; path(includeHash?: boolean): string; prepareExternalUrl(internal: string): string; pushState(ctx: any, title: string, path: string, query: string): void; replaceState(ctx: any, title: string, path: string, query: string): void; onPopState(fn: (value: any) => void): void; getBaseHref(): string; back(): void; forward(): void; }
declare const _default: (string[][] | undefined)[]; export default _default;
import { AsyncAction } from './AsyncAction'; import { AsyncScheduler } from './AsyncScheduler'; export const async = new AsyncScheduler(AsyncAction);
export * from 'rxjs-compat/operators/max';
export * from 'rxjs-compat/operator/retryWhen';
export declare enum RequestMethod { Get = 0, Post = 1, Put = 2, Delete = 3, Options = 4, Head = 5, Patch = 6 } export declare enum ReadyState { Unsent = 0, Open = 1, HeadersReceived = 2, Loading = 3, Done = 4, Cancelled = 5 } export declare enum ResponseType { Basic = 0, Cors = 1, Default = 2, Error = 3, Opaque = 4 } export declare enum ContentType { NONE = 0, JSON = 1, FORM = 2, FORM_DATA = 3, TEXT = 4, BLOB = 5, ARRAY_BUFFER = 6 } export declare enum ResponseContentType { Text = 0, Json = 1, ArrayBuffer = 2, Blob = 3 }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'FJD': string[]; 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import { IRuleMetadata, RuleFailure, Rules } from 'tslint/lib'; import { SourceFile } from 'typescript/lib/typescript'; export declare class Rule extends Rules.AbstractRule { static readonly metadata: IRuleMetadata; static readonly FAILURE_STRING: string; apply(sourceFile: SourceFile): RuleFailure[]; } export declare const getFailureMessage: () => string;
Zone.__load_patch('getUserMedia', (global: any, Zone: any, api: _ZonePrivate) => { function wrapFunctionArgs(func: Function, source?: string): Function { return function() { const args = Array.prototype.slice.call(arguments); const wrappedArgs = api.bindArguments(args, source ? source : (func as any).name); return func.apply(this, wrappedArgs); }; } let navigator = global['navigator']; if (navigator && navigator.getUserMedia) { navigator.getUserMedia = wrapFunctionArgs(navigator.getUserMedia); } });
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'PHP': string[]; 'USD': string[]; } | undefined)[]; export default _default;
export declare const enum I18nMutateOpCode { SHIFT_REF = 2, SHIFT_PARENT = 17, MASK_OPCODE = 3, MASK_REF = 68, Select = 0, AppendChild = 1, InsertBefore = 2, Remove = 3 } export declare const ELEMENT_MARKER: ELEMENT_MARKER; export interface ELEMENT_MARKER { marker: 'element'; } export declare const COMMENT_MARKER: COMMENT_MARKER; export interface COMMENT_MARKER { marker: 'comment'; } export interface I18nMutateOpCodes extends Array<number | string | ELEMENT_MARKER | COMMENT_MARKER | null> { } export declare const enum I18nUpdateOpCode { SHIFT_REF = 2, SHIFT_ICU = 17, MASK_OPCODE = 3, MASK_REF = 68, Text = 0, Attr = 1, IcuSwitch = 2, IcuUpdate = 3 } export interface I18nUpdateOpCodes extends Array<string | number | ((text: string) => string | null)> { } export interface TI18n { vars: number; expandoStartIndex: number; create: I18nMutateOpCodes; update: I18nUpdateOpCodes; icus: TIcu[] | null; } export declare const enum IcuType { select = 0, plural = 1 } export interface TIcu { type: IcuType; vars: number[]; childIcus: number[][]; expandoStartIndex: number; cases: any[]; create: I18nMutateOpCodes[]; remove: I18nMutateOpCodes[]; update: I18nUpdateOpCodes[]; } export interface LI18n extends Array<number> { }
declare const _default: ((string[] | undefined)[] | (string | string[])[] | undefined)[]; export default _default;
export * from 'rxjs-compat/operators/buffer';
import { ArchitectCommand, ArchitectCommandOptions } from '../models/architect-command'; import { Arguments } from '../models/interface'; import { Schema as RunCommandSchema } from './run'; export declare class RunCommand extends ArchitectCommand<RunCommandSchema> { run(options: ArchitectCommandOptions & Arguments): Promise<number>; }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import { Operator } from '../Operator'; import { Observable } from '../Observable'; import { Subscriber } from '../Subscriber'; import { Notification } from '../Notification'; import { OperatorFunction } from '../types'; export function dematerialize<T>(): OperatorFunction<Notification<T>, T> { return function dematerializeOperatorFunction(source: Observable<Notification<T>>) { return source.lift(new DeMaterializeOperator()); }; } class DeMaterializeOperator<T extends Notification<any>, R> implements Operator<T, R> { call(subscriber: Subscriber<any>, source: any): any { return source.subscribe(new DeMaterializeSubscriber(subscriber)); } } class DeMaterializeSubscriber<T extends Notification<any>> extends Subscriber<T> { constructor(destination: Subscriber<any>) { super(destination); } protected _next(value: T) { value.observe(this.destination); } }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': string[]; 'BRL': (string | undefined)[]; 'CAD': (string | undefined)[]; 'CNY': string[]; 'ESP': string[]; 'JPY': string[]; 'MXN': (string | undefined)[]; 'THB': string[]; 'USD': (string | undefined)[]; 'VEF': never[]; 'XCD': (string | undefined)[]; } | undefined)[]; export default _default;
import 'rxjs-compat/add/operator/audit';
import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { AppRoutingModule } from './app-routing.module'; import { AppComponent } from './app.component'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, AppRoutingModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': (string | undefined)[]; 'BBD': string[]; 'BMD': string[]; 'BRL': string[]; 'BSD': string[]; 'BZD': string[]; 'CNY': (string | undefined)[]; 'DKK': string[]; 'DOP': string[]; 'EEK': string[]; 'EGP': string[]; 'ESP': never[]; 'GBP': (string | undefined)[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'INR': (string | undefined)[]; 'ISK': string[]; 'JMD': string[]; 'JPY': (string | undefined)[]; 'KRW': (string | undefined)[]; 'NOK': string[]; 'NZD': (string | undefined)[]; 'RON': (string | undefined)[]; 'SEK': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'VND': (string | undefined)[]; } | undefined)[]; export default _default;
import { Injector } from '../di'; import { DebugContext } from '../view/index'; export declare class EventListener { name: string; callback: Function; constructor(name: string, callback: Function); } export declare class DebugNode { nativeNode: any; private _debugContext; listeners: EventListener[]; parent: DebugElement | null; constructor(nativeNode: any, parent: DebugNode | null, _debugContext: DebugContext); readonly injector: Injector; readonly componentInstance: any; readonly context: any; readonly references: { [key: string]: any; }; readonly providerTokens: any[]; } export declare class DebugElement extends DebugNode { name: string; properties: { [key: string]: any; }; attributes: { [key: string]: string | null; }; classes: { [key: string]: boolean; }; styles: { [key: string]: string | null; }; childNodes: DebugNode[]; nativeElement: any; constructor(nativeNode: any, parent: any, _debugContext: DebugContext); addChild(child: DebugNode): void; removeChild(child: DebugNode): void; insertChildrenAfter(child: DebugNode, newChildren: DebugNode[]): void; insertBefore(refChild: DebugNode, newChild: DebugNode): void; query(predicate: Predicate<DebugElement>): DebugElement; queryAll(predicate: Predicate<DebugElement>): DebugElement[]; queryAllNodes(predicate: Predicate<DebugNode>): DebugNode[]; readonly children: DebugElement[]; triggerEventHandler(eventName: string, eventObj: any): void; } export declare function asNativeElements(debugEls: DebugElement[]): any; export declare function getDebugNode(nativeNode: any): DebugNode | null; export declare function getAllDebugNodes(): DebugNode[]; export declare function indexDebugNode(node: DebugNode): void; export declare function removeDebugNodeFromIndex(node: DebugNode): void; export interface Predicate<T> { (value: T): boolean; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import 'rxjs-compat/add/observable/zip';
export * from 'rxjs-compat/operators/catchError';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'JPY': string[]; 'MZN': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare const _default: never[]; export default _default;
import { InjectionToken } from './di'; export declare const APP_INITIALIZER: InjectionToken<(() => void)[]>; export declare class ApplicationInitStatus { private appInits; private resolve; private reject; private initialized; readonly donePromise: Promise<any>; readonly done = false; constructor(appInits: (() => any)[]); }
import { Subject } from '../Subject'; import { Subscriber } from '../Subscriber'; import { Subscription } from '../Subscription'; import { Scheduler } from '../Scheduler'; import { TestMessage } from './TestMessage'; import { SubscriptionLog } from './SubscriptionLog'; import { SubscriptionLoggable } from './SubscriptionLoggable'; import { applyMixins } from '../util/applyMixins'; export class HotObservable<T> extends Subject<T> implements SubscriptionLoggable { public subscriptions: SubscriptionLog[] = []; scheduler: Scheduler; logSubscribedFrame: () => number; logUnsubscribedFrame: (index: number) => void; constructor(public messages: TestMessage[], scheduler: Scheduler) { super(); this.scheduler = scheduler; } _subscribe(subscriber: Subscriber<any>): Subscription { const subject: HotObservable<T> = this; const index = subject.logSubscribedFrame(); const subscription = new Subscription(); subscription.add(new Subscription(() => { subject.logUnsubscribedFrame(index); })); subscription.add(super._subscribe(subscriber)); return subscription; } setup() { const subject = this; const messagesLength = subject.messages.length; for (var i = 0; i < messagesLength; i++) { (() => { var message = subject.messages[i]; subject.scheduler.schedule( () => { message.notification.observe(subject); }, message.frame ); })(); } } } applyMixins(HotObservable, [SubscriptionLoggable]);
export * from 'rxjs-compat/operators/concat';
import * as ts from 'typescript'; import { Maybe } from './function'; export declare function callExpression(dec?: ts.Decorator): Maybe<ts.CallExpression | undefined>; export declare function hasProperties(expr?: ts.ObjectLiteralExpression): boolean; export declare function objectLiteralExpression(expr?: ts.CallExpression): Maybe<ts.ObjectLiteralExpression | undefined>; export declare function withIdentifier(identifier: string): (expr: ts.CallExpression) => Maybe<ts.CallExpression | undefined>; export declare function isProperty(propName: string, p: ts.ObjectLiteralElement): boolean; export declare function getInitializer(p: ts.ObjectLiteralElement): Maybe<ts.Expression | undefined>; export declare function getStringInitializerFromProperty(propertyName: string, ps: ts.NodeArray<ts.ObjectLiteralElement>): Maybe<ts.StringLiteral | undefined>; export declare function decoratorArgument(dec: ts.Decorator): Maybe<ts.ObjectLiteralExpression | undefined>;
declare const pTry: { <ValueType, ArgumentsType extends unknown[]>( fn: (...arguments: ArgumentsType) => PromiseLike<ValueType> | ValueType, ...arguments: ArgumentsType ): Promise<ValueType>; default: typeof pTry; }; export = pTry;
import 'rxjs-compat/add/operator/skipWhile';
import { By, ByHash, promise as wdpromise, WebDriver, WebElement } from 'selenium-webdriver'; export declare class WebdriverBy { className: (className: string) => By; css: (css: string) => By; id: (id: string) => By; linkText: (linkText: string) => By; js: (js: string | Function, ...var_args: any[]) => By; name: (name: string) => By; partialLinkText: (partialText: string) => By; tagName: (tagName: string) => By; xpath: (xpath: string) => By; } export declare type WebDriverLocator = By | ByHash | Function; export interface ProtractorLocator { findElementsOverride: (driver: WebDriver, using: WebElement, rootSelector: string) => wdpromise.Promise<WebElement[]>; row?: (index: number) => Locator; column?: (index: string) => Locator; toString?: () => string; } export declare type Locator = ProtractorLocator | WebDriverLocator; export declare function isProtractorLocator(x: Locator): x is ProtractorLocator; export declare class ProtractorBy extends WebdriverBy { [key: string]: any; addLocator(name: string, script: Function | string): void; binding(bindingDescriptor: string): ProtractorLocator; exactBinding(bindingDescriptor: string): ProtractorLocator; model(model: string): ProtractorLocator; buttonText(searchText: string): ProtractorLocator; partialButtonText(searchText: string): ProtractorLocator; private byRepeaterInner(exact, repeatDescriptor); repeater(repeatDescriptor: string): ProtractorLocator; exactRepeater(repeatDescriptor: string): ProtractorLocator; cssContainingText(cssSelector: string, searchText: string | RegExp): ProtractorLocator; options(optionsDescriptor: string): ProtractorLocator; deepCss(selector: string): Locator; }
import { PlatformRef, StaticProvider } from '@angular/core'; export declare const platformCoreDynamic: (extraProviders?: StaticProvider[] | undefined) => PlatformRef;
export * from 'rxjs-compat/operator/publishLast';
export * from 'rxjs-compat/observable/dom/WebSocketSubject';
import { AsyncPipe } from './async_pipe'; import { LowerCasePipe, TitleCasePipe, UpperCasePipe } from './case_conversion_pipes'; import { DatePipe } from './date_pipe'; import { I18nPluralPipe } from './i18n_plural_pipe'; import { I18nSelectPipe } from './i18n_select_pipe'; import { JsonPipe } from './json_pipe'; import { KeyValue, KeyValuePipe } from './keyvalue_pipe'; import { CurrencyPipe, DecimalPipe, PercentPipe } from './number_pipe'; import { SlicePipe } from './slice_pipe'; export { AsyncPipe, CurrencyPipe, DatePipe, DecimalPipe, KeyValue, KeyValuePipe, I18nPluralPipe, I18nSelectPipe, JsonPipe, LowerCasePipe, PercentPipe, SlicePipe, TitleCasePipe, UpperCasePipe, }; export declare const COMMON_PIPES: (typeof AsyncPipe | typeof SlicePipe | typeof DecimalPipe | typeof PercentPipe | typeof CurrencyPipe | typeof DatePipe | typeof I18nPluralPipe | typeof I18nSelectPipe | typeof KeyValuePipe)[];
<%= experimentalIvy ? ' <%= experimentalIvy ? ' <%= experimentalIvy ? ' <%= experimentalIvy ? ' <%= experimentalIvy ? ' <%= experimentalIvy ? ' <%= experimentalIvy ? ' <%= experimentalIvy ? ' <%= experimentalIvy ? ' <%= experimentalIvy ? ' <%= experimentalIvy ? ' <%= experimentalIvy ? ' <% if (experimentalIvy) { %> import { AppComponent } from './app/app.component'; import { ɵrenderComponent as renderComponent } from '@angular/core'; renderComponent(AppComponent); <% } %>
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': string[]; 'AUD': string[]; 'BEF': string[]; 'BMD': string[]; 'BND': string[]; 'BSD': string[]; 'BZD': string[]; 'CAD': string[]; 'CLP': string[]; 'CNY': (string | undefined)[]; 'COP': string[]; 'CYP': string[]; 'EGP': (string | undefined)[]; 'FJD': string[]; 'FKP': string[]; 'FRF': string[]; 'GBP': string[]; 'GIP': string[]; 'HKD': (string | undefined)[]; 'IEP': string[]; 'ILP': string[]; 'ITL': string[]; 'JPY': (string | undefined)[]; 'KMF': (string | undefined)[]; 'LBP': string[]; 'MTP': string[]; 'MXN': string[]; 'NAD': string[]; 'NIO': (string | undefined)[]; 'NZD': string[]; 'RHD': string[]; 'RON': (string | undefined)[]; 'RWF': (string | undefined)[]; 'SBD': string[]; 'SGD': string[]; 'SRD': string[]; 'TTD': string[]; 'TWD': (string | undefined)[]; 'USD': string[]; 'UYU': string[]; 'WST': string[]; 'XCD': (string | undefined)[]; 'XPF': string[]; 'ZMW': (string | undefined)[]; } | undefined)[]; export default _default;
import * as ts from 'typescript'; import { TypeCtorMetadata } from './api'; export declare function generateTypeCtor(node: ts.ClassDeclaration, meta: TypeCtorMetadata): ts.MethodDeclaration;
export const errorObject: any = { e: {} };
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'ARS': never[]; 'AUD': never[]; 'BBD': never[]; 'BDT': never[]; 'BGN': string[]; 'BMD': never[]; 'BND': never[]; 'BRL': never[]; 'BSD': never[]; 'BYN': never[]; 'BZD': never[]; 'CAD': never[]; 'CLP': never[]; 'CNY': never[]; 'COP': never[]; 'CRC': never[]; 'CUP': never[]; 'DOP': never[]; 'FJD': never[]; 'GBP': (string | undefined)[]; 'GIP': never[]; 'GYD': never[]; 'HKD': never[]; 'ILS': never[]; 'INR': never[]; 'JMD': never[]; 'JPY': (string | undefined)[]; 'KHR': never[]; 'KRW': never[]; 'KYD': never[]; 'KZT': never[]; 'LAK': never[]; 'LRD': never[]; 'MNT': never[]; 'MXN': never[]; 'NAD': never[]; 'NGN': never[]; 'NZD': never[]; 'PHP': never[]; 'PYG': never[]; 'RON': never[]; 'SBD': never[]; 'SGD': never[]; 'SRD': never[]; 'SSP': never[]; 'TRY': never[]; 'TTD': never[]; 'TWD': never[]; 'UAH': never[]; 'USD': string[]; 'UYU': never[]; 'VND': never[]; 'XCD': (string | undefined)[]; } | undefined)[]; export default _default;
export interface PipeTransform { transform(value: any, ...args: any[]): any; }
import { Observable } from '../Observable'; export function scalar<T>(value: T) { const result = new Observable<T>(subscriber => { subscriber.next(value); subscriber.complete(); }); result._isScalar = true; (result as any).value = value; return result; }
import { CreateFileError } from "./errors/CreateFileError"; import { LaunchEditorError } from "./errors/LaunchEditorError"; import { ReadFileError } from "./errors/ReadFileError"; import { RemoveFileError } from "./errors/RemoveFileError"; export interface IEditorParams { args: string[]; bin: string; } export interface IFileOptions { prefix?: string; postfix?: string; mode?: number; template?: string; dir?: string; } export declare type StringCallback = (err: Error, result: string) => void; export declare type VoidCallback = () => void; export { CreateFileError, LaunchEditorError, ReadFileError, RemoveFileError }; export declare function edit(text?: string, fileOptions?: IFileOptions): string; export declare function editAsync(text: string, callback: StringCallback, fileOptions?: IFileOptions): void; export declare class ExternalEditor { private static splitStringBySpace; text: string; tempFile: string; editor: IEditorParams; lastExitStatus: number; private fileOptions; readonly temp_file: string; readonly last_exit_status: number; constructor(text?: string, fileOptions?: IFileOptions); run(): string; runAsync(callback: StringCallback): void; cleanup(): void; private determineEditor; private createTemporaryFile; private readTemporaryFile; private removeTemporaryFile; private launchEditor; private launchEditorAsync; }
import 'rxjs-compat/add/operator/windowCount';
export {};
export declare const latestVersions: { Angular: string; RxJs: string; ZoneJs: string; TypeScript: string; DevkitBuildAngular: string; DevkitBuildNgPackagr: string; };
export * from 'rxjs-compat/AsyncSubject';
export * from 'rxjs-compat/operator/isEmpty';
export * from './index'; export { HttpClientTestingBackend as ɵangular_packages_common_http_testing_testing_a } from './src/backend';
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'DKK': string[]; 'JPY': string[]; 'NOK': string[]; 'SEK': string[]; 'THB': string[]; 'USD': string[]; } | undefined)[]; export default _default;
declare const _default: ((string[] | undefined)[] | undefined)[]; export default _default;
import { Version } from '@angular/core'; export declare const VERSION: Version;
import { reduce } from './reduce'; import { MonoTypeOperatorFunction } from '../types'; export function min<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T> { const min: (x: T, y: T) => T = (typeof comparer === 'function') ? (x, y) => comparer(x, y) < 0 ? x : y : (x, y) => x < y ? x : y; return reduce(min); }
import { Operator } from '../Operator'; import { Subscriber } from '../Subscriber'; import { Observable } from '../Observable'; import { empty } from '../observable/empty'; import { MonoTypeOperatorFunction, TeardownLogic } from '../types'; export function repeat<T>(count: number = -1): MonoTypeOperatorFunction<T> { return (source: Observable<T>) => { if (count === 0) { return empty(); } else if (count < 0) { return source.lift(new RepeatOperator(-1, source)); } else { return source.lift(new RepeatOperator(count - 1, source)); } }; } class RepeatOperator<T> implements Operator<T, T> { constructor(private count: number, private source: Observable<T>) { } call(subscriber: Subscriber<T>, source: any): TeardownLogic { return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source)); } } class RepeatSubscriber<T> extends Subscriber<T> { constructor(destination: Subscriber<any>, private count: number, private source: Observable<T>) { super(destination); } complete() { if (!this.isStopped) { const { source, count } = this; if (count === 0) { return super.complete(); } else if (count > -1) { this.count = count - 1; } source.subscribe(this._unsubscribeAndRecycle()); } } }
Zone.__load_patch('jsonp', (global: any, Zone: ZoneType, api: _ZonePrivate) => { const noop = function() {}; (Zone as any)[Zone.__symbol__('jsonp')] = function patchJsonp(options: any) { if (!options || !options.jsonp || !options.sendFuncName) { return; } const noop = function() {}; [options.successFuncName, options.failedFuncName].forEach(methodName => { if (!methodName) { return; } const oriFunc = global[methodName]; if (oriFunc) { api.patchMethod(global, methodName, (delegate: Function) => (self: any, args: any[]) => { const task = global[api.symbol('jsonTask')]; if (task) { task.callback = delegate; return task.invoke.apply(self, args); } else { return delegate.apply(self, args); } }); } else { Object.defineProperty(global, methodName, { configurable: true, enumerable: true, get: function() { return function() { const task = global[api.symbol('jsonpTask')]; const target = this ? this : global; const delegate = global[api.symbol(`jsonp${methodName}callback`)]; if (task) { if (delegate) { task.callback = delegate; } global[api.symbol('jsonpTask')] = undefined; return task.invoke.apply(this, arguments); } else { if (delegate) { return delegate.apply(this, arguments); } } return null; }; }, set: function(callback: Function) { this[api.symbol(`jsonp${methodName}callback`)] = callback; } }); } }); api.patchMethod( options.jsonp, options.sendFuncName, (delegate: Function) => (self: any, args: any[]) => { global[api.symbol('jsonpTask')] = Zone.current.scheduleMacroTask('jsonp', noop, {}, (task: Task) => { return delegate.apply(self, args); }, noop); }); }; });
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AED': string[]; 'ARS': (string | undefined)[]; 'AUD': string[]; 'BBD': (string | undefined)[]; 'BHD': string[]; 'BMD': (string | undefined)[]; 'BND': (string | undefined)[]; 'BSD': (string | undefined)[]; 'BZD': (string | undefined)[]; 'CAD': string[]; 'CLP': (string | undefined)[]; 'CNY': string[]; 'COP': (string | undefined)[]; 'CUP': (string | undefined)[]; 'DOP': (string | undefined)[]; 'DZD': string[]; 'EGP': string[]; 'FJD': (string | undefined)[]; 'GBP': string[]; 'GYD': (string | undefined)[]; 'HKD': string[]; 'IQD': string[]; 'IRR': string[]; 'JMD': (string | undefined)[]; 'JOD': string[]; 'JPY': string[]; 'KWD': string[]; 'KYD': (string | undefined)[]; 'LBP': string[]; 'LYD': string[]; 'MAD': string[]; 'MRO': string[]; 'MXN': string[]; 'NZD': string[]; 'OMR': string[]; 'QAR': string[]; 'SAR': string[]; 'SBD': (string | undefined)[]; 'SDD': string[]; 'SDG': string[]; 'SRD': (string | undefined)[]; 'SYP': string[]; 'THB': string[]; 'TND': string[]; 'TTD': (string | undefined)[]; 'TWD': string[]; 'USD': string[]; 'UYU': (string | undefined)[]; 'XXX': string[]; 'YER': string[]; } | undefined)[]; export default _default;
export declare function _sanitizeHtml(defaultDoc: any, unsafeHtmlInput: string): string;
declare const _default: never[]; export default _default;
export * from 'rxjs-compat/operators/debounce';
export * from 'rxjs-compat/operators/retry';
import { MonoTypeOperatorFunction, SchedulerLike } from '../types'; export declare function endWith<T>(scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>; export declare function endWith<T>(v1: T, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>; export declare function endWith<T>(v1: T, v2: T, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>; export declare function endWith<T>(v1: T, v2: T, v3: T, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>; export declare function endWith<T>(v1: T, v2: T, v3: T, v4: T, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>; export declare function endWith<T>(v1: T, v2: T, v3: T, v4: T, v5: T, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>; export declare function endWith<T>(v1: T, v2: T, v3: T, v4: T, v5: T, v6: T, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>; export declare function endWith<T>(...array: Array<T | SchedulerLike>): MonoTypeOperatorFunction<T>;
export * from './index'; export { TestBedRender3 as ɵangular_packages_core_testing_testing_b, _getTestBedRender3 as ɵangular_packages_core_testing_testing_c } from './src/r3_test_bed'; export { TestBedViewEngine as ɵangular_packages_core_testing_testing_a } from './src/test_bed';
export interface Schema { configuration?: string; help?: HelpUnion; prod?: boolean; project?: string; } export declare type HelpUnion = boolean | HelpEnum; export declare enum HelpEnum { HelpJSON = "JSON", JSON = "json" }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
import { Operator } from '../Operator'; import { Subscriber } from '../Subscriber'; import { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError'; import { empty } from '../observable/empty'; import { Observable } from '../Observable'; import { MonoTypeOperatorFunction, TeardownLogic } from '../types'; export function takeLast<T>(count: number): MonoTypeOperatorFunction<T> { return function takeLastOperatorFunction(source: Observable<T>): Observable<T> { if (count === 0) { return empty(); } else { return source.lift(new TakeLastOperator(count)); } }; } class TakeLastOperator<T> implements Operator<T, T> { constructor(private total: number) { if (this.total < 0) { throw new ArgumentOutOfRangeError; } } call(subscriber: Subscriber<T>, source: any): TeardownLogic { return source.subscribe(new TakeLastSubscriber(subscriber, this.total)); } } class TakeLastSubscriber<T> extends Subscriber<T> { private ring: Array<T> = new Array(); private count: number = 0; constructor(destination: Subscriber<T>, private total: number) { super(destination); } protected _next(value: T): void { const ring = this.ring; const total = this.total; const count = this.count++; if (ring.length < total) { ring.push(value); } else { const index = count % total; ring[index] = value; } } protected _complete(): void { const destination = this.destination; let count = this.count; if (count > 0) { const total = this.count >= this.total ? this.total : this.count; const ring = this.ring; for (let i = 0; i < total; i++) { const idx = (count++) % total; destination.next(ring[idx]); } } destination.complete(); } }
import { CustomReporterResult } from "../../spec-reporter"; import { DisplayProcessor } from "../display-processor"; export declare class DefaultProcessor extends DisplayProcessor { private static displaySpecDescription(spec); displayJasmineStarted(): String; displaySuite(suite: CustomReporterResult): String; displaySuccessfulSpec(spec: CustomReporterResult): String; displayFailedSpec(spec: CustomReporterResult): String; displaySpecErrorMessages(spec: CustomReporterResult): String; displaySummaryErrorMessages(spec: CustomReporterResult): String; displayPendingSpec(spec: CustomReporterResult): String; private displayErrorMessages(spec, withStacktrace); }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'DKK': string[]; 'JPY': string[]; 'USD': string[]; } | undefined)[]; export default _default;
import '../zone'; import '../common/promise'; import '../common/to-string'; import '../browser/browser'; import '../node/node';
import * as q from 'q'; import { WebDriver } from 'selenium-webdriver'; import { Config } from '../config'; import { DriverProvider } from './driverProvider'; export declare class MockExecutor { execute(command: any): any; } export declare class Mock extends DriverProvider { constructor(config?: Config); execute(): q.Promise<any>; protected setupDriverEnv(): q.Promise<any>; getNewDriver(): WebDriver; }
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'BYN': string[]; 'GEL': (string | undefined)[]; 'RON': (string | undefined)[]; 'RUB': string[]; 'THB': string[]; 'TMT': string[]; 'TWD': string[]; 'UAH': string[]; 'XXX': string[]; } | undefined)[]; export default _default;
export * from 'rxjs-compat/operators/publishLast';
declare global { const ngDevMode: null | NgDevModePerfCounters; interface NgDevModePerfCounters { firstTemplatePass: number; tNode: number; tView: number; rendererCreateTextNode: number; rendererSetText: number; rendererCreateElement: number; rendererAddEventListener: number; rendererSetAttribute: number; rendererRemoveAttribute: number; rendererSetProperty: number; rendererSetClassName: number; rendererAddClass: number; rendererRemoveClass: number; rendererSetStyle: number; rendererRemoveStyle: number; rendererDestroy: number; rendererDestroyNode: number; rendererMoveNode: number; rendererRemoveNode: number; rendererCreateComment: number; } } export declare function ngDevModeResetPerfCounters(): NgDevModePerfCounters;
import { DirectiveDef } from '../interfaces/definition'; export declare function PublicFeature<T>(definition: DirectiveDef<T>): void;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export * from 'rxjs-compat/operators/publishLast';
import { ArchitectCommand, ArchitectCommandOptions } from '../models/architect-command'; import { Arguments } from '../models/interface'; import { Schema as TestCommandSchema } from './test'; export declare class TestCommand extends ArchitectCommand<TestCommandSchema> { readonly target = "test"; readonly multiTarget = true; run(options: ArchitectCommandOptions & Arguments): Promise<number>; }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export * from 'rxjs-compat/util/ObjectUnsubscribedError';
import { MonoTypeOperatorFunction } from '../types'; export declare function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T>;
declare function plural(n: number): number; declare const _default: (string | number | (string[] | undefined)[] | number[] | (string | undefined)[] | typeof plural | { 'AUD': string[]; 'CAD': string[]; 'FJD': string[]; 'JPY': string[]; 'SBD': string[]; 'THB': string[]; 'TWD': string[]; 'USD': string[]; 'XPF': never[]; } | undefined)[]; export default _default;
export interface Position { fileName: string; line: number; column: number; } export interface FormattedMessageChain { message: string; position?: Position; next?: FormattedMessageChain; } export declare type FormattedError = Error & { chain: FormattedMessageChain; position?: Position; }; export declare function formattedError(chain: FormattedMessageChain): FormattedError; export declare function isFormattedError(error: Error): error is FormattedError;
export * from 'rxjs-compat/operator/max';
export * from 'rxjs-compat/observable/combineLatest';
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.TypedRule { static metadata: Lint.IRuleMetadata; static EMPTY_INTERFACE_INSTANCE: string; static EMPTY_INTERFACE_FUNCTION: string; applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): Lint.RuleFailure[]; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING_MISSING: string; static FAILURE_STRING_COMMA: string; static FAILURE_STRING_UNNECESSARY: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
export * from 'rxjs-compat/operator/mapTo';
import 'rxjs-compat/add/operator/mergeMapTo';
import { ComponentRef } from '@angular/core'; export declare function enableDebugTools<T>(ref: ComponentRef<T>): ComponentRef<T>; export declare function disableDebugTools(): void;
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
export declare class Error { name?: string; message: string; stack?: string; constructor(message?: string); } export declare class FatalError extends Error { message: string; innerError?: Error | undefined; static NAME: string; constructor(message: string, innerError?: Error | undefined); } export declare function isError(possibleError: any): possibleError is Error; export declare function showWarningOnce(message: string): void; export declare function showRuleCrashWarning(message: string, ruleName: string, fileName: string): void;
import * as ts from "typescript"; import { Visibility } from "../completedDocsRule"; import { Exclusion } from "./exclusion"; export interface IBlockExclusionDescriptor { visibilities?: Visibility[]; } export declare class BlockExclusion extends Exclusion<IBlockExclusionDescriptor> { readonly visibilities: Set<Visibility>; excludes(node: ts.Node): boolean; }
export declare const codeExamples: { description: string; config: string; pass: string; fail: string; }[];
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export * from './public_api';
export interface IVisitor { visitTag(tag: Tag): any; visitText(text: Text): any; visitDeclaration(decl: Declaration): any; visitDoctype(doctype: Doctype): any; } export declare function serialize(nodes: Node[]): string; export interface Node { visit(visitor: IVisitor): any; } export declare class Declaration implements Node { attrs: { [k: string]: string; }; constructor(unescapedAttrs: { [k: string]: string; }); visit(visitor: IVisitor): any; } export declare class Doctype implements Node { rootTag: string; dtd: string; constructor(rootTag: string, dtd: string); visit(visitor: IVisitor): any; } export declare class Tag implements Node { name: string; children: Node[]; attrs: { [k: string]: string; }; constructor(name: string, unescapedAttrs?: { [k: string]: string; }, children?: Node[]); visit(visitor: IVisitor): any; } export declare class Text implements Node { value: string; constructor(unescapedValue: string); visit(visitor: IVisitor): any; } export declare class CR extends Text { constructor(ws?: number); } export declare function escapeXml(text: string): string;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export * from './animations/animations';
export declare class StaticSymbol { filePath: string; name: string; members: string[]; constructor(filePath: string, name: string, members: string[]); assertNoMembers(): void; } export declare class StaticSymbolCache { private cache; get(declarationFile: string, name: string, members?: string[]): StaticSymbol; }
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare const _default: never[]; export default _default;
export { Formatter as JsonFormatter } from "./jsonFormatter"; export { Formatter as PmdFormatter } from "./pmdFormatter"; export { Formatter as ProseFormatter } from "./proseFormatter"; export { Formatter as VerboseFormatter } from "./verboseFormatter"; export { Formatter as StylishFormatter } from "./stylishFormatter"; export { Formatter as FileslistFormatter } from "./fileslistFormatter"; export { Formatter as CodeFrameFormatter } from "./codeFrameFormatter"; export { Formatter as TapFormatter } from "./tapFormatter"; export { Formatter as JUnitFormatter } from "./junitFormatter";
import { ImportManager } from '../../../ngtsc/translator'; export declare class NgccImportManager extends ImportManager { private isFlat; constructor(isFlat: boolean, isCore: boolean, prefix?: string); generateNamedImport(moduleName: string, symbol: string): string | null; }
import { BuildEvent, Builder, BuilderConfiguration, BuilderContext } from '@angular-devkit/architect'; import { LoggingCallback } from '@angular-devkit/build-webpack'; import { Path, virtualFs } from '@angular-devkit/core'; import * as fs from 'fs'; import { Observable } from 'rxjs'; import { AssetPatternObject, BrowserBuilderSchema, CurrentFileReplacement } from './schema'; export interface NormalizedBrowserBuilderSchema extends BrowserBuilderSchema { assets: AssetPatternObject[]; fileReplacements: CurrentFileReplacement[]; } export declare class BrowserBuilder implements Builder<BrowserBuilderSchema> { context: BuilderContext; constructor(context: BuilderContext); run(builderConfig: BuilderConfiguration<BrowserBuilderSchema>): Observable<BuildEvent>; buildWebpackConfig(root: Path, projectRoot: Path, host: virtualFs.Host<fs.Stats>, options: NormalizedBrowserBuilderSchema): any; private _deleteOutputDir; } export declare const getBrowserLoggingCb: (verbose: boolean) => LoggingCallback; export default BrowserBuilder;
import { ExtraEntryPoint } from '../../browser/schema'; export declare function generateEntryPoints(appConfig: { styles: ExtraEntryPoint[]; scripts: ExtraEntryPoint[]; }): string[];
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_CONSTRUCTOR_ONLY: string; static FAILURE_STATIC_ONLY: string; static FAILURE_EMPTY_CLASS: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import { ChangeDetectorRef, ComponentFactoryResolver, ComponentRef, EventEmitter, OnDestroy, OnInit, ViewContainerRef } from '@angular/core'; import { Data } from '../config'; import { ChildrenOutletContexts } from '../router_outlet_context'; import { ActivatedRoute } from '../router_state'; export declare class RouterOutlet implements OnDestroy, OnInit { private parentContexts; private location; private resolver; private changeDetector; private activated; private _activatedRoute; private name; activateEvents: EventEmitter<any>; deactivateEvents: EventEmitter<any>; constructor(parentContexts: ChildrenOutletContexts, location: ViewContainerRef, resolver: ComponentFactoryResolver, name: string, changeDetector: ChangeDetectorRef); ngOnDestroy(): void; ngOnInit(): void; readonly isActivated: boolean; readonly component: Object; readonly activatedRoute: ActivatedRoute; readonly activatedRouteData: Data; detach(): ComponentRef<any>; attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute): void; deactivate(): void; activateWith(activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver | null): void; }
import { Observable } from 'rxjs'; import { Action, CreateFileAction, DeleteFileAction, OverwriteFileAction, RenameFileAction } from '../tree/action'; import { Tree } from '../tree/interface'; export interface Sink { commit(tree: Tree): Observable<void>; } export declare abstract class SimpleSinkBase implements Sink { preCommitAction: (action: Action) => void | Action | PromiseLike<Action> | Observable<Action>; postCommitAction: (action: Action) => void | Observable<void>; preCommit: () => void | Observable<void>; postCommit: () => void | Observable<void>; protected abstract _validateFileExists(p: string): Observable<boolean>; protected abstract _overwriteFile(path: string, content: Buffer): Observable<void>; protected abstract _createFile(path: string, content: Buffer): Observable<void>; protected abstract _renameFile(path: string, to: string): Observable<void>; protected abstract _deleteFile(path: string): Observable<void>; protected abstract _done(): Observable<void>; protected _fileAlreadyExistException(path: string): void; protected _fileDoesNotExistException(path: string): void; protected _validateOverwriteAction(action: OverwriteFileAction): Observable<void>; protected _validateCreateAction(action: CreateFileAction): Observable<void>; protected _validateRenameAction(action: RenameFileAction): Observable<void>; protected _validateDeleteAction(action: DeleteFileAction): Observable<void>; validateSingleAction(action: Action): Observable<void>; commitSingleAction(action: Action): Observable<void>; commit(tree: Tree): Observable<void>; }
export interface Schema { builder: string; configurations?: { [key: string]: { [key: string]: any; }; }; options: { [key: string]: any; }; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING: string; static FAILURE_STRING_MULTILINE: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import { Rule } from '@angular-devkit/schematics'; export default function (): Rule;
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING_ARRAY: string; static FAILURE_STRING_GENERIC: string; static FAILURE_STRING_ARRAY_SIMPLE: string; static FAILURE_STRING_GENERIC_SIMPLE: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import { NgModuleFactory, NgModuleRef, Type } from '@angular/core'; import { Observable } from 'rxjs'; import { UrlSegment, UrlSegmentGroup } from './url_tree'; export declare type Routes = Route[]; export declare type UrlMatchResult = { consumed: UrlSegment[]; posParams?: { [name: string]: UrlSegment; }; }; export declare type UrlMatcher = (segments: UrlSegment[], group: UrlSegmentGroup, route: Route) => UrlMatchResult; export declare type Data = { [name: string]: any; }; export declare type ResolveData = { [name: string]: any; }; export declare type LoadChildrenCallback = () => Type<any> | NgModuleFactory<any> | Promise<Type<any>> | Observable<Type<any>>; export declare type LoadChildren = string | LoadChildrenCallback; export declare type QueryParamsHandling = 'merge' | 'preserve' | ''; export declare type RunGuardsAndResolvers = 'paramsChange' | 'paramsOrQueryParamsChange' | 'always'; export interface Route { path?: string; pathMatch?: string; matcher?: UrlMatcher; component?: Type<any>; redirectTo?: string; outlet?: string; canActivate?: any[]; canActivateChild?: any[]; canDeactivate?: any[]; canLoad?: any[]; data?: Data; resolve?: ResolveData; children?: Routes; loadChildren?: LoadChildren; runGuardsAndResolvers?: RunGuardsAndResolvers; } export declare class LoadedRouterConfig { routes: Route[]; module: NgModuleRef<any>; constructor(routes: Route[], module: NgModuleRef<any>); } export declare function validateConfig(config: Routes, parentPath?: string): void; export declare function standardizeConfig(r: Route): Route;
import { ComponentFactoryResolver, ComponentRef } from '@angular/core'; import { RouterOutlet } from './directives/router_outlet'; import { ActivatedRoute } from './router_state'; export declare class OutletContext { outlet: RouterOutlet | null; route: ActivatedRoute | null; resolver: ComponentFactoryResolver | null; children: ChildrenOutletContexts; attachRef: ComponentRef<any> | null; } export declare class ChildrenOutletContexts { private contexts; onChildOutletCreated(childName: string, outlet: RouterOutlet): void; onChildOutletDestroyed(childName: string): void; onOutletDeactivated(): Map<string, OutletContext>; onOutletReAttached(contexts: Map<string, OutletContext>): void; getOrCreateContext(childName: string): OutletContext; getContext(childName: string): OutletContext | null; }
import { BaseException } from '@angular-devkit/core'; import { Observable } from 'rxjs'; import { Rule, SchematicContext, Source } from '../engine/interface'; import { Tree } from '../tree/interface'; export declare class InvalidRuleResultException extends BaseException { constructor(value?: {}); } export declare class InvalidSourceResultException extends BaseException { constructor(value?: {}); } export declare function callSource(source: Source, context: SchematicContext): Observable<Tree>; export declare function callRule(rule: Rule, input: Observable<Tree>, context: SchematicContext): Observable<Tree>;
import { WebpackConfigOptions } from '../build-options'; export declare const buildOptimizerLoader: string; export declare function getCommonConfig(wco: WebpackConfigOptions): { mode: string; devtool: boolean; resolve: { extensions: string[]; symlinks: boolean; modules: string[]; alias: {}; }; resolveLoader: { modules: string[]; }; context: string; entry: { [key: string]: string[]; }; output: { path: string; publicPath: string | undefined; filename: string; }; watch: boolean | undefined; watchOptions: { poll: number | undefined; }; performance: { hints: boolean; }; module: { rules: ({ test: RegExp; loader: string; options?: undefined; parser?: undefined; } | { test: RegExp; loader: string; options: { name: string; }; parser?: undefined; } | { test: RegExp; parser: { system: boolean; }; loader?: undefined; options?: undefined; } | { test: RegExp; loader?: undefined; options?: undefined; parser?: undefined; } | { use: { loader: string; options: { sourceMap: boolean | undefined; }; }[]; test: RegExp; loader?: undefined; options?: undefined; parser?: undefined; } | { test: RegExp; exclude: RegExp; enforce: string; loader?: undefined; options?: undefined; parser?: undefined; } | { use: { loader: string; }[]; test: RegExp; exclude: RegExp; enforce: string; loader?: undefined; options?: undefined; parser?: undefined; })[]; }; optimization: { noEmitOnErrors: boolean; minimizer: any[]; }; plugins: any[]; };
import { Compiler } from 'webpack'; export interface CleanCssWebpackPluginOptions { sourceMap: boolean; test: (file: string) => boolean; } export declare class CleanCssWebpackPlugin { private readonly _options; constructor(options: Partial<CleanCssWebpackPluginOptions>); apply(compiler: Compiler): void; }
import * as ts from "typescript"; import * as Lint from "../index"; export declare class Rule extends Lint.Rules.AbstractRule { static metadata: Lint.IRuleMetadata; static FAILURE_STRING_DUPLICATE: string; static FAILURE_STRING_LOOP: string; apply(sourceFile: ts.SourceFile): Lint.RuleFailure[]; }
import { AnimationPlayer } from '@angular/animations'; export declare class NoopAnimationDriver implements AnimationDriver { validateStyleProperty(prop: string): boolean; matchesElement(element: any, selector: string): boolean; containsElement(elm1: any, elm2: any): boolean; query(element: any, selector: string, multi: boolean): any[]; computeStyle(element: any, prop: string, defaultValue?: string): string; animate(element: any, keyframes: { [key: string]: string | number; }[], duration: number, delay: number, easing: string, previousPlayers?: any[], scrubberAccessRequested?: boolean): AnimationPlayer; } export declare abstract class AnimationDriver { static NOOP: AnimationDriver; abstract validateStyleProperty(prop: string): boolean; abstract matchesElement(element: any, selector: string): boolean; abstract containsElement(elm1: any, elm2: any): boolean; abstract query(element: any, selector: string, multi: boolean): any[]; abstract computeStyle(element: any, prop: string, defaultValue?: string): string; abstract animate(element: any, keyframes: { [key: string]: string | number; }[], duration: number, delay: number, easing?: string | null, previousPlayers?: any[], scrubberAccessRequested?: boolean): any; }
import * as ts from 'typescript'; import { NgccReflectionHost, SwitchableVariableDeclaration } from '../host/ngcc_host'; export interface SwitchMarkerAnalysis { sourceFile: ts.SourceFile; declarations: SwitchableVariableDeclaration[]; } export declare type SwitchMarkerAnalyses = Map<ts.SourceFile, SwitchMarkerAnalysis>; export declare const SwitchMarkerAnalyses: MapConstructor; export declare class SwitchMarkerAnalyzer { private host; constructor(host: NgccReflectionHost); analyzeProgram(program: ts.Program): SwitchMarkerAnalyses; }
export * from './index';
declare const _default: never[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
declare const _default: ((string[] | undefined)[] | (string | string[])[])[]; export default _default;
export * from './index'; export { BaseAnimationRenderer as ɵangular_packages_platform_browser_animations_animations_g } from './src/animation_renderer'; export { BROWSER_ANIMATIONS_PROVIDERS as ɵangular_packages_platform_browser_animations_animations_e, BROWSER_NOOP_ANIMATIONS_PROVIDERS as ɵangular_packages_platform_browser_animations_animations_f, InjectableAnimationEngine as ɵangular_packages_platform_browser_animations_animations_a, instantiateDefaultStyleNormalizer as ɵangular_packages_platform_browser_animations_animations_c, instantiateRendererFactory as ɵangular_packages_platform_browser_animations_animations_d, instantiateSupportedAnimationDriver as ɵangular_packages_platform_browser_animations_animations_b } from './src/providers';
